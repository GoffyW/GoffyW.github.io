<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ajax+json</title>
      <link href="/2019/02/20/Ajax/"/>
      <url>/2019/02/20/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Ajax-json"><a href="#Ajax-json" class="headerlink" title="Ajax+json"></a>Ajax+json</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>​    在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点</p><h4 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h4><ol><li>需要测试浏览器的支持</li><li>网页的后退功能是失效的，需要明显的提示用户“数据已更新”</li><li>手机设备，支持不是很友好</li></ol><h4 id="对象（重要）"><a href="#对象（重要）" class="headerlink" title="对象（重要）"></a>对象（重要）</h4><ol><li><h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><p>提供客户端同HTTP服务器通讯的协议</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"MSXML2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>指定当readyState属性改变时的事件处理句柄</p><pre class=" language-JS"><code class="language-JS">var xmlhttp=null;function PostOrder(xmldoc){  var xmlhttp = new ActiveXObject("Msxml2.XMLHTTP.5.0");  xmlhttp.Open("POST", "http://myserver/orders/processorder.asp", false);   xmlhttp.onreadystatechange= HandleStateChange;  xmlhttp.Send(xmldoc);  myButton.disabled = true;}function HandleStateChange(){  if (xmlhttp.readyState == 4)  {    myButton.disabled = false;    alert("Result = " + xmlhttp.responseXML.xml);  }}</code></pre></li><li><h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>返回当前请求的http状态码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>常用状态码以及含义：</p><ol><li>404  没找到页面(not found)</li><li>403  禁止访问(forbidden)</li><li>500  内部服务器出错(internal service error)</li><li>200  一切正常(ok)</li><li>304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 )</li></ol></li><li><h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>返回XMLHTTP请求的当前状态</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> XmlHttp<span class="token punctuation">;</span>XmlHttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   XmlHttp<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> doHttpReadyStateChange<span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">doHttpReadyStateChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>XmlHttp<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>备注：</p><p>| 0 (未初始化)   |        对象已建立，但是尚未初始化（尚未调用open方法）        |<br>| ————– | :———————————————————-: |<br>| 1 (初始化)     |                 对象已建立，尚未调用send方法                 |<br>| 2 (发送数据)   |          send方法已调用，但是当前的状态及http头未知          |<br>| 3 (数据传送中) | 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 |<br>| 4 (完成)       | 数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据 |</p></li><li><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>创建一个新的http请求，并指定此请求的方法、URL以及验证信息</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> book <span class="token operator">=</span> xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span><span class="token function">selectSingleNode</span><span class="token punctuation">(</span><span class="token string">"//book[@id='bk101']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>open()语法：</p><pre class=" language-js"><code class="language-js">oXMLHttpRequest<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>bstrMethod<span class="token punctuation">,</span> bstrUrl<span class="token punctuation">,</span> varAsync<span class="token punctuation">,</span> bstrUser<span class="token punctuation">,</span> bstrPassword<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、bstrMethod</p><pre><code>http方法，例如：POST、GET、PUT及PROPFIND。大小写不敏感。</code></pre><p>​     <strong>如果用 POST 请求向服务器发送数据，需要将“Content-type” 的首部设置为“application/x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经 符合URL编码了</strong></p><pre class=" language-js"><code class="language-js">ajax<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、bstrUrl</p><pre><code>请求的URL地址，可以为绝对地址也可以为相对地址。 </code></pre><p>3、varAsync[可选]</p><pre><code>布尔型，指定此请求是否为异步方式，默认为true。如果为真，当状态改变时会调用onreadystatechange属性指定的回调函数。 </code></pre><p>4、bstrUser[可选]</p><pre><code>如果服务器需要验证，此处指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。 </code></pre><p>5、bstrPassword[可选]</p><pre><code>验证信息中的密码部分，如果用户名为空，则此值将被忽略。 </code></pre></li><li><h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>发送请求到http服务器并接收回应</p><pre class=" language-js"><code class="language-js">xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令</p><p>2、data：将要传递给服务器的字符串。</p><p>3、若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null);</p><p>4、当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null</p></li></ol><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><h4 id="方式1（利用js原生）"><a href="#方式1（利用js原生）" class="headerlink" title="方式1（利用js原生）"></a>方式1（利用js原生）</h4><pre class=" language-js"><code class="language-js"> $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span><span class="token string">"post"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求方式</span>        url<span class="token punctuation">:</span><span class="token string">"data.jsp"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求地址</span>        data<span class="token punctuation">:</span>params<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//传输的数据，参数</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//服务器返回的话（数据）</span>        <span class="token keyword">var</span> jdata <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//data.trim()是去除返回数据的空格</span>        jdata <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token operator">+</span> jdata <span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="方式2（利用jQuery）"><a href="#方式2（利用jQuery）" class="headerlink" title="方式2（利用jQuery）"></a>方式2（利用jQuery）</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> object <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">parseJSON</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2019/02/20/Maven/"/>
      <url>/2019/02/20/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven学习"><a href="#Maven学习" class="headerlink" title="Maven学习"></a>Maven学习</h1><h4 id="Maven项目目录说明："><a href="#Maven项目目录说明：" class="headerlink" title="Maven项目目录说明："></a>Maven项目目录说明：</h4><ol><li>根目录：工程名</li><li>src目录：源码</li><li>pom.xml文件：Maven工程的核心控制文件</li><li>main目录：存放主程序</li><li>test目录：存放测试程序</li><li>java目录：存放Java源文件</li><li>resources目录：存放框架与其他工具的配置文件</li></ol><h4 id="为什么遵守："><a href="#为什么遵守：" class="headerlink" title="为什么遵守："></a>为什么遵守：</h4><p>约定&gt;配置&gt;编码</p><h4 id="常用的Maven命令："><a href="#常用的Maven命令：" class="headerlink" title="常用的Maven命令："></a>常用的Maven命令：</h4><ol><li>mvn compile    编译</li><li>mvn clean    清理</li><li>mvn test    测试</li><li>mvn package    打包</li></ol><h4 id="Maven依赖范围（scope）："><a href="#Maven依赖范围（scope）：" class="headerlink" title="Maven依赖范围（scope）："></a>Maven依赖范围（scope）：</h4><ol><li><p>compile</p><ul><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：参与</li></ul></li><li><p>test</p><ul><li><p>对主程序是否有效：无效</p></li><li><p>对测试程序是否有效：有效</p></li><li><p>是否参与打包：不参与</p></li></ul></li><li><p>provided</p><ul><li><p>对主程序是否有效：有效</p></li><li><p>对测试程序是否有效：有效</p></li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li></ol><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><h4 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a>依赖的传递性：</h4><p>​    优点：可以传递的依赖不必在每个模块下都重复声明，在”最下面“的工程中依赖一次即可</p><p>​    注意：非compile范围的依赖不能传递</p><h4 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a>依赖的排除：</h4><p>​    依赖排除的场合：只对自己起作用</p><h4 id="依赖的原则："><a href="#依赖的原则：" class="headerlink" title="依赖的原则："></a>依赖的原则：</h4><p>作用：解决jar包冲突的问题</p><ul><li>就近原则</li><li>先声明者优先</li></ul><h4 id="统一管理依赖的版本号："><a href="#统一管理依赖的版本号：" class="headerlink" title="统一管理依赖的版本号："></a>统一管理依赖的版本号：</h4><p>​    使用propertier标签声明，各自里面使用${}替换</p><h4 id="依赖的继承："><a href="#依赖的继承：" class="headerlink" title="依赖的继承："></a>依赖的继承：</h4><p>问题：由于test范围的依赖不能传递，所以必然分散在每一个模块中，造成版本不一致</p><p>解决：将test依赖范围的jar包统一提取到”父 “工程中，在子工程中不声明jar包的版本，统一使用”父“工程中的jar包的版本号</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2018/12/29/Thread/"/>
      <url>/2018/12/29/Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="一、线程与进程的5个阶段"><a href="#一、线程与进程的5个阶段" class="headerlink" title="一、线程与进程的5个阶段"></a>一、线程与进程的5个阶段</h5><p>创建、就绪、运行、阻塞、终止</p><h5 id="二、实现多线程的方法（3种）"><a href="#二、实现多线程的方法（3种）" class="headerlink" title="二、实现多线程的方法（3种）"></a>二、实现多线程的方法（3种）</h5><ol><li>扩展java.lang.Thread类</li><li>实现java.lang.Runable接口</li><li>实现Callable接口，并与 Future、线程池结合使用</li></ol><h5 id="三、分类介绍"><a href="#三、分类介绍" class="headerlink" title="三、分类介绍"></a>三、分类介绍</h5><ol><li><h6 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Thread1</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"运行："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Thread1 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"jordan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread1 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"kobe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><p>jordan运行：0<br>kobe运行：0<br>kobe运行：1<br>kobe运行：2<br>jordan运行：1<br>kobe运行：3<br>jordan运行：2<br>kobe运行：4<br>jordan运行：3<br>jordan运行：4</p><blockquote><p>注意：</p><ol><li>start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的</li><li>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程</li><li>Thread.sleep() 方法调用目的是不让当前线程独自霸占该进程所获取的 CPU 资源，以留出一定时间给其他线程执行的机会</li><li>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的</li><li>start 方法重复调用的话，会出现 java.lang.IllegalThreadStateException 异常</li></ol></blockquote><h6 id="2-实现Runable接口"><a href="#2-实现Runable接口" class="headerlink" title="2.实现Runable接口"></a>2.实现Runable接口</h6><pre class=" language-Java"><code class="language-Java">package com.test.thread;public class Thread2 implements Runnable {    private String name;    public Thread2(String name) {        super();        this.name = name;    }    @Override    public void run() {        // TODO Auto-generated method stub        for (int i = 0; i < 5; i++) {            System.out.println(name+"运行："+i);        }        try {            Thread.sleep((long) (Math.random()*10));        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}//测试类package com.test.thread;public class Test2 {    public static void main(String[] args) {        // TODO Auto-generated method stub        new Thread(new Thread2("jordan")).start();        new Thread(new Thread2("kobe")).start();    }}</code></pre><h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><p>如果一个类继承 Thread，则不适合资源共享。但是如果实现了 Runable 接口的话，则很容易的实现资源共享</p><h6 id="总结：（实现Runable接口继承Thread的优点）"><a href="#总结：（实现Runable接口继承Thread的优点）" class="headerlink" title="总结：（实现Runable接口继承Thread的优点）"></a>总结：（实现Runable接口继承Thread的优点）</h6><ol><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免Java单继承的缺点</li><li>增加程序的健壮性，代码可以被多个线程共享，代码和数据共享</li><li>线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</li></ol><blockquote><p>注意：main 方法其实也是一个线程。在 java 中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到 CPU 的资源</p></blockquote><h5 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h5><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p><p>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>（一）、等待阻塞：运行的线程执行 wait() 方法，JVM 会把该线程放入等待池中。(wait 会释放持有的锁)</p><p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中。</p><p>（三）、其他阻塞：运行的线程执行 sleep() 或 join() 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。（注意, sleep 是不会释放持有的锁）</p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。</p><h5 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h5><ol><li><p>调整线程优先级：Java 线程有优先级，优先级高的线程会获得较多的运行机会</p><p>Java 线程的优先级用整数表示，取值范围是 1~10，Thread 类有以下三个静态常量：</p><blockquote><pre class=" language-Java"><code class="language-Java"></code></pre><p>static int MAX_PRIORITY</p><pre><code>   //线程可以具有的最高优先级，取值为10。</code></pre><p>static int MIN_PRIORITY</p><pre><code>   //线程可以具有的最低优先级，取值为1。</code></pre><p>static int NORM_PRIORITY</p><pre><code>   //分配给线程的默认优先级，取值为5。</code></pre><pre><code></code></pre></blockquote></li></ol><p>Thread 类的 setPriority() 和 getPriority() 方法分别用来设置和获取线程的优先级</p><p>每个线程都有默认的优先级。主线程的默认优先级为 Thread.NORM_PRIORITY</p><p>线程的优先级有继承关系，比如 A 线程中创建了 B 线程，那么 B 将和 A 具有相同的优先级</p><p>JVM 提供了 10 个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用 Thread 类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式</p></li><li><p>线程睡眠（sleep()）:Thread()的方法，使线程转到阻塞状态，结束后，线程转入就绪（Runable）状态</p></li><li><p>线程等待（wait()）:Object()的方法，使线程等待，直到其他线程调用此对象的notify(all)()方法时方可唤醒此线程</p></li><li><p>线程让步（yield()）:Thread()的方法，暂停正在执行的线程，将执行让给有优先级相同或者更高的线程执行</p></li><li><p>线程加入（join()）:Thread()的方法，在当前线程调用其他线程的join()方法，当前线程转入阻塞状态，直到被调用的线程运行完毕，当前线程由阻塞状态转为就绪状态</p></li><li><p>线程唤醒（notify()）:Object()的方法，</p></li></ol><p>注意：Thread 中 suspend() 和 resume() 两个方法在 JDK1.5 中已经废除，不再介绍。因为有死锁倾向</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传项目到Github</title>
      <link href="/2018/09/07/GitToGithub/"/>
      <url>/2018/09/07/GitToGithub/</url>
      
        <content type="html"><![CDATA[<h3 id="Git上传项目到Github"><a href="#Git上传项目到Github" class="headerlink" title="Git上传项目到Github"></a>Git上传项目到Github</h3><h4 id="0、新建文件夹"><a href="#0、新建文件夹" class="headerlink" title="0、新建文件夹"></a>0、新建文件夹</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036553006.png" alt="1559036553006"></p><h4 id="1、在此文件夹右键Git-Bash-Here，输入命令"><a href="#1、在此文件夹右键Git-Bash-Here，输入命令" class="headerlink" title="1、在此文件夹右键Git Bash Here，输入命令"></a>1、在此文件夹右键Git Bash Here，输入命令</h4><pre class=" language-Java"><code class="language-Java">git init</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036600072.png" alt="1559036600072"></p><p>此步操作为初始化git工作区间</p><h4 id="2、将需要上传的项目复制到工作区间"><a href="#2、将需要上传的项目复制到工作区间" class="headerlink" title="2、将需要上传的项目复制到工作区间"></a>2、将需要上传的项目复制到工作区间</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036752091.png" alt="1559036752091"></p><h4 id="3、输入命令git-status-查看git工作区间的文件变化"><a href="#3、输入命令git-status-查看git工作区间的文件变化" class="headerlink" title="3、输入命令git status 查看git工作区间的文件变化"></a>3、输入命令git status 查看git工作区间的文件变化</h4><pre><code>git status</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036885875.png" alt="1559036885875"></p><h4 id="4、输入命令git-add-将文件加入到暂存区"><a href="#4、输入命令git-add-将文件加入到暂存区" class="headerlink" title="4、输入命令git add . 将文件加入到暂存区"></a>4、输入命令git add . 将文件加入到暂存区</h4><pre><code>git add .</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036995464.png" alt="1559036995464"></p><h4 id="5、将文件提交到本地仓库"><a href="#5、将文件提交到本地仓库" class="headerlink" title="5、将文件提交到本地仓库"></a>5、将文件提交到本地仓库</h4><pre><code>git commit -m &quot;the first commit&quot;</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037091035.png" alt="1559037091035"></p><h4 id="6、在Github种新建仓库"><a href="#6、在Github种新建仓库" class="headerlink" title="6、在Github种新建仓库"></a>6、在Github种新建仓库</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037194341.png" alt="1559037194341"></p><p>7、复制仓库链接（https链接）</p><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037237509.png" alt="1559037237509"></p><h4 id="8、将本地仓库关联到Github仓库"><a href="#8、将本地仓库关联到Github仓库" class="headerlink" title="8、将本地仓库关联到Github仓库"></a>8、将本地仓库关联到Github仓库</h4><pre><code>git remote add origin https://...</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037332932.png" alt="1559037332932"></p><h4 id="9、将本地仓库同步到GitHub仓库"><a href="#9、将本地仓库同步到GitHub仓库" class="headerlink" title="9、将本地仓库同步到GitHub仓库"></a>9、将本地仓库同步到GitHub仓库</h4><pre><code>git push origin master</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037744888.png" alt="1559037744888"></p><h3 id="一点一点积累"><a href="#一点一点积累" class="headerlink" title="一点一点积累"></a>一点一点积累</h3><p>git拉取远程仓库代码与本地合并：</p><pre><code>git pull origin master</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1562244421283.png" alt="1562244421283"></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Night watcher swear</title>
      <link href="/2018/09/07/Aray/"/>
      <url>/2018/09/07/Aray/</url>
      
        <content type="html"><![CDATA[<h3 id="Night-watcher-swear"><a href="#Night-watcher-swear" class="headerlink" title="Night watcher swear"></a>Night watcher swear</h3><p>Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.</p><p>长夜将至，我从今开始守望，至死方休。我将不娶妻、不封地、不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死於斯。我是黑暗中的利剑，长城上的守卫。我是抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。</p>]]></content>
      
      
      <categories>
          
          <category> xxx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2018/08/02/MyBatis/"/>
      <url>/2018/08/02/MyBatis/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h4><h5 id="配置文件与映射文件"><a href="#配置文件与映射文件" class="headerlink" title="配置文件与映射文件"></a>配置文件与映射文件</h5><h5 id="MyBatisCRUD操作"><a href="#MyBatisCRUD操作" class="headerlink" title="MyBatisCRUD操作"></a>MyBatisCRUD操作</h5><h5 id="ResultType与ResultMap区别"><a href="#ResultType与ResultMap区别" class="headerlink" title="ResultType与ResultMap区别"></a>ResultType与ResultMap区别</h5><p>实体类与表中字段不一致时</p><ol><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致，这样就可以表的字段名和实体类的属性名一一对应上了，这种方式是通过在sql语句中定义别名来解决字段名和属性名的映射关系的。</li><li>通过<resultmap>来映射字段名和实体类属性名的一一对应关系。这种方式是使用MyBatis提供的解决方式来解决字段名和属性名的映射关系的</resultmap></li></ol><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>​    if，choose (when, otherwise)，trim (where, set)，foreach</p><h5 id="一对一，一对多，多对多高级映射（association-collection）"><a href="#一对一，一对多，多对多高级映射（association-collection）" class="headerlink" title="一对一，一对多，多对多高级映射（association,collection）"></a>一对一，一对多，多对多高级映射（association,collection）</h5><ol><li>一对一关联，使用assacation标签</li><li>一对多关联，使用collection标签。collection标签来解决一对多的关联查询，ofType属性指定集合中元素的对象类型         </li></ol><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p>​    mybatis默认没有开启延迟加载，需要在MyBaits-Config.xml中setting配置</p><p>​    使用association、collection能实现表间关联，association、collection也具备延迟加载功能延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><h5 id="一级缓存、二级缓存"><a href="#一级缓存、二级缓存" class="headerlink" title="一级缓存、二级缓存"></a>一级缓存、二级缓存</h5><ol><li>一级缓存默认开启，作用域一个sqlSession中，两个查询之后第二次查询会在缓存之中查找，提交查找效率，如果进行commit()（insert,update,delete）操作，则清空缓存。</li><li>二级缓存默认开启，需要在xml文件中配置，其作用域为一个Mapper，即namespace，所以需要在对应的xml文件中进行配置。而且缓存可自定义存储源（Redis,EhCache,MemcCache）</li></ol><h5 id="分页、批量"><a href="#分页、批量" class="headerlink" title="分页、批量"></a>分页、批量</h5><ol><li>mybatis的分页功能，可以自己利用mysql代码实现，也可以利用mybatis分页插件,如pageHelper</li><li>批量则依赖于SQL语句</li></ol><h5 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h5>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(感想)</title>
      <link href="/2018/02/24/MySQL/"/>
      <url>/2018/02/24/MySQL/</url>
      
        <content type="html"><![CDATA[<h4 id="MySQL感想"><a href="#MySQL感想" class="headerlink" title="MySQL感想"></a>MySQL感想</h4><h4 id="行是物理存在的，而分组是逻辑存在的。"><a href="#行是物理存在的，而分组是逻辑存在的。" class="headerlink" title="行是物理存在的，而分组是逻辑存在的。"></a>行是物理存在的，而分组是逻辑存在的。</h4><p>一行数据和一列数据都能被人们感知，一行数据会携带一个主键；而一列数据，不仅有列名，还有列的类型。</p><p>看的见的东西很重要，但是看不见的东西也同样重要，甚至看错的东西更重要。这个人生哲理放在数据库里面，同样成立</p><p>在一次测试种，10000 条记录的数据表中，查找一次平均需要 5000 次比较，而在使用了索引的表中只需要 14 次。</p><p>10000 对 14 的对比</p><h4 id="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"><a href="#索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。" class="headerlink" title="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"></a>索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。</h4><ol><li>索引占用一定的磁盘空间，就像新华字典有目录便要比没有目录的厚一点</li><li>索引大大减缓了插入和删数据的效率，因为每次插入都需要更新索引，一个表拥有的索引越多，进行写操作时平均性能就急剧下降</li></ol><p>数据分组用来将数据分为多个逻辑组，从而可以对每个组进行聚合运算，使用方式为：GROUP BY分组字段。分组语句必须和聚合函数一起使用，GROUP BY子句负责将数据分成逻辑组，而聚函数则对每一个组进行统计计算。</p><p>虽然GROUP BY子句常常和聚合函数起使用，不过GROUP BY子句并不是不能离开聚合函数而单独使用的</p><h4 id="数据分组有以下三大特点"><a href="#数据分组有以下三大特点" class="headerlink" title="数据分组有以下三大特点"></a>数据分组有以下三大特点</h4><ol><li><h5 id="分组与聚合函数"><a href="#分组与聚合函数" class="headerlink" title="分组与聚合函数"></a>分组与聚合函数</h5><p>要分组的所有列都必须位于 GROUP BY子句的列名列表中，也就是没有出现在GROUP BY子句中的列(聚合函数除外)是不能放到SELECET语句后的列名列表中的。比如下面的SQL语句是错误的：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age, salary FROM t_employee GROUP BY age;</code></pre><p>道理非常简单，采用分组以后的查询结果集是以分组形式提供的，由于每组中人员的工资都不样，所以就不存在能够统代表本组工资水平的salary字段了，所以上面的SQL语句是错误的。不过每组中员工的平均工资却能够统一代表本组工水平，所以可以对Salary使用聚合函数，下面的SQL语句则是正确的：</p><pre><code>SELECT age, AVG(salary) FROM t_Employee GROUP BY age;</code></pre></li><li><h5 id="多级数据分组"><a href="#多级数据分组" class="headerlink" title="多级数据分组"></a>多级数据分组</h5><p>GROUP BY子句中可以指定多个列，只需要将多个列的列名用逗号隔开即。指定多个分组规则以后，数据库系统将按照定义的分组顺序来对数据进行逐分组。首先按照第一个分组列进行分组，然后在每个小组内按照第一个分组列行再次分组…逐层分组，从而实现“组中组”的效果，而查询的结果集是以末一级分组来进行输出的。比如下面的SQL语句将会列出所有分公司的所有门的情况：</p><pre class=" language-mysql"><code class="language-mysql">SELECT subcompany, department FROM t_employee GROUP BY subcompany, department;</code></pre></li><li><h5 id="数据分组特点三：数据分组过滤使用HAVING语句"><a href="#数据分组特点三：数据分组过滤使用HAVING语句" class="headerlink" title="数据分组特点三：数据分组过滤使用HAVING语句"></a>数据分组特点三：数据分组过滤使用HAVING语句</h5><p>有的时候需要对部分分组进行过滤，比如只检索人数大于1的年龄段，有的开发人员会使用下面的SQL语句：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age where count(*) > 1 ;</code></pre><p>在数据库系统中执行上面的SQL语句时，数据库系统会提示语法错误。这是因为聚合函数不能在WHERE语句中使用，必须使用HAVING子句来代替，比如:</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age having count(*) > 1 ;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMapAndConcurrentHashMap</title>
      <link href="/2018/02/21/HashMapAndConcurrentHashMap/"/>
      <url>/2018/02/21/HashMapAndConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h3><h5 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h5><p><img src="C:\Users\Goffy\Desktop\继承图谱\HashMap.jpg" alt></p><h5 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h5><p>JDK1.8之前：数组+链表（散列集）</p><p>JDK1.8之后：数组+链表（散列集）+红黑二叉树</p><h5 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891042167.png" alt="1557891042167"></p><ol><li>序列化机制验证版本</li><li>初始容量</li><li>最大容量，2的31次方</li><li>默认装载因子</li><li>当添加一个元素被添加到有至少TREEIFY_THRESHOLD节点的桶中，桶中链表将转化为链表</li><li>同上，不过是将树形结构转化为链表</li><li>桶可能被转化成树形结构的最小容量</li></ol><h6 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h6><pre class=" language-Java"><code class="language-Java">private static final long serialVersionUID = 362498820763181265L;static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16static final int MAXIMUM_CAPACITY = 1 << 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891742915.png" alt="1557891742915"></p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557892222219.png" alt="1557892222219"></p><h5 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h5><ul><li>无序、允许为Null、非同步</li><li>底层由散列表实现</li><li>初始容量和加载因子对其影响较大</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList.asList()总结</title>
      <link href="/2018/02/20/Arrays.asList/"/>
      <url>/2018/02/20/Arrays.asList/</url>
      
        <content type="html"><![CDATA[<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><h3 id="Arrays-asList-可以将一个数组转化为集合，但是："><a href="#Arrays-asList-可以将一个数组转化为集合，但是：" class="headerlink" title="Arrays.asList()可以将一个数组转化为集合，但是："></a>Arrays.asList()可以将一个数组转化为集合，但是：</h3><p>该方法为泛型方法，具体实现为</p><pre class=" language-Java"><code class="language-Java">public static <T> List<T> asList(T... a) {    return new ArrayList<>(a);}</code></pre><p>使用时必须注意的事项：</p><ol><li><p>传递的必须为对象数组，而不是基本类型。</p><pre class=" language-Java"><code class="language-Java">int [] myArray1 = { 1, 2, 3 };List myList1 = Arrays.asList(myArray1);System.out.println(myList1.size());//1System.out.println(myList1.get(0));//数组地址值 [I@1b6d3586</code></pre></li><li><p>当传入一个基本数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>解决这个问题只需要将数组类型变成他的包装类型</p><pre class=" language-Java"><code class="language-Java">Integer[] myArray1 = { 1, 2, 3 };</code></pre></li><li><p>使用集合的修改方法:add()、remove()、clear()会抛出异常。</p><pre class=" language-Java"><code class="language-Java">List myList1 = Arrays.asList(1, 2, 3);myList1.add(4);//运行时报错：UnsupportedOperationExceptionmyList1.remove(1);//运行时报错：UnsupportedOperationExceptionmyList1.clear();//运行时报错：UnsupportedOperationException</code></pre><p>因为：Arrays.asList()的返回值是 <code>java.util.Arrays</code> 的一个内部类，并不是java.util.ArrayList</p><pre class=" language-Java"><code class="language-Java">System.out.println("-----------"+myList1.getClass());//-----------class java.util.Arrays$ArrayList</code></pre></li></ol><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些</p><pre class=" language-Java"><code class="language-Java"> private static class ArrayList<E> extends AbstractList<E>        implements RandomAccess, java.io.Serializable    {        ...        @Override        public E get(int index) {          ...        }        @Override        public E set(int index, E element) {          ...        }        @Override        public int indexOf(Object o) {          ...        }        @Override        public boolean contains(Object o) {           ...        }        @Override        public void forEach(Consumer<? super E> action) {          ...        }        @Override        public void replaceAll(UnaryOperator<E> operator) {          ...        }        @Override        public void sort(Comparator<? super E> c) {          ...        }    }</code></pre><p><code>java.util.AbstractList</code>的<code>remove()</code>,理解为什么会抛出UnsupportedOperationException()异常</p><pre class=" language-Java"><code class="language-Java">public E remove(int index) {    throw new UnsupportedOperationException();}</code></pre><h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList?"></a>如何正确的将数组转换为ArrayList?</h3><ol><li><p><strong>最简便的方法(推荐)</strong></p><pre class=" language-Java"><code class="language-Java">List list = new ArrayList<>(Arrays.asList("a", "b", "c"))</code></pre></li><li><p><strong>使用 Java8 的Stream(推荐)</strong></p><pre class=" language-Java"><code class="language-Java">Integer [] myArray = { 1, 2, 3 };List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = { 1, 2, 3 };List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre></li><li><p><strong>使用 Guava(推荐)</strong></p><ol><li><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="noopener"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="noopener"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="noopener"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><pre class=" language-Java"><code class="language-Java">List<String> il = ImmutableList.of("string", "elements");  // from varargsList<String> il = ImmutableList.copyOf(aStringArray);      // from array</code></pre></li><li><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="noopener"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="noopener"><code>newArrayList()</code></a>工厂方法：</p><pre class=" language-Java"><code class="language-Java">List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collectionList<String> l2 = Lists.newArrayList(aStringArray);               // from arrayList<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs</code></pre></li></ol></li><li><p><strong>使用 Apache Commons Collections</strong></p><pre class=" language-Java"><code class="language-Java">List<String> list = new ArrayList<String>();CollectionUtils.addAll(list, str);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arrays </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet</title>
      <link href="/2018/02/20/servlet/"/>
      <url>/2018/02/20/servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><h3 id="处理中文乱码问题"><a href="#处理中文乱码问题" class="headerlink" title="处理中文乱码问题"></a>处理中文乱码问题</h3><h5 id="请求中文乱码解决"><a href="#请求中文乱码解决" class="headerlink" title="请求中文乱码解决"></a>请求中文乱码解决</h5><ol><li>使用String进行数据重新编码</li></ol><pre class=" language-Java"><code class="language-Java">uname = new String(uname.getBytes("iso8859-1"),"utf-8");</code></pre><ol start="2"><li><p>使用公共配置</p><ul><li><p>get方法：</p><p>步骤一：</p><pre class=" language-Java"><code class="language-Java">request.setCharacterEncoding("utf-8");</code></pre><p>步骤二：</p><p>在Tomcat的目录下的conf目录中的修改server.xml文件，在Connector标签中增加useBodyEncodingForURI=”true”</p></li><li><p>post方法：</p><pre class=" language-Java"><code class="language-Java">resp.setContentType("text/html; charset=UTF-8");</code></pre></li></ul></li></ol><h3 id="forward-与-sendRedirect"><a href="#forward-与-sendRedirect" class="headerlink" title="forward 与 sendRedirect"></a>forward 与 sendRedirect</h3><table><thead><tr><th></th><th>重定向</th><th>请求转发</th></tr></thead><tbody><tr><td>第二次请求是谁请求的？</td><td>浏览器</td><td>服务器</td></tr><tr><td>浏览器发生了几次请求？</td><td>2</td><td>1</td></tr><tr><td>servlet可以共享request吗？</td><td>不可以</td><td>可以</td></tr><tr><td>地址栏是否发生改变？</td><td>是</td><td>否</td></tr><tr><td>浏览器显示的是那一次的访问地址？</td><td>最后一次</td><td>第一次</td></tr><tr><td>可以跳转到什么资源</td><td>任意资源</td><td>项目内部</td></tr><tr><td>第二次请求路径是？</td><td>绝对路径</td><td>内部路径</td></tr></tbody></table><ol><li><p>​    重定向（sendRedirect）</p><pre class=" language-Java"><code class="language-Java">resp.sendRedirect("path");</code></pre><ol><li>​    两次请求    两个request对象，数据不共享</li><li>​    浏览器地址栏信息改变</li></ol></li><li><p>请求转发（forward） </p><pre class=" language-Java"><code class="language-Java">req.getRequestDispatcher("path").forward(req, resp);</code></pre><ol><li>一次请求</li><li>浏览器地址不发生改变</li></ol></li><li><p>使用场景：</p><ol><li>如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向</li><li>如果请求被servlet接收后，无法进行处理，建议使用重定向定位到可以处理资源的servlet上</li></ol></li><li><p>选择</p><ol><li>重定向的速度比转发慢，因为浏览器还得发出一个新的请求，如果在使用转发和重定向都无所谓的时候建议使用转发。</li><li>因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO/NIO</title>
      <link href="/2018/02/20/JavaIO/"/>
      <url>/2018/02/20/JavaIO/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaIO-NIO"><a href="#JavaIO-NIO" class="headerlink" title="JavaIO/NIO"></a>JavaIO/NIO</h3><h3 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h3><p>在Java.io包下主要包括两种流输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。其中字节流以字节单位来处理输入、输出操作。而字符流则以字符处理输入、输出操作。</p><ul><li><p>字符流</p><ul><li>Reader<ul><li>BufferedReader</li><li>InputStreamReader</li><li>StringReader</li><li>CharArrayReader</li><li>FileReader</li><li>…</li></ul></li><li>Writer<ul><li>BufferedWriter</li><li>OutputStreamWriter</li><li>StringWriter</li><li>CharArrayWriter</li><li>FileWriter</li><li>…</li></ul></li></ul></li><li><p>字节流</p><ul><li>InputStream<ul><li>FileInputStream</li><li>StringBufferInputStream</li><li>ByteArrayInputStream</li><li>…</li></ul></li><li>OutputStream<ul><li>FileOutputStream</li><li>StringBufferOutputStream</li><li>ByteArrayOutputStream</li><li>…</li></ul></li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Non-blocking I/O</p><p>一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式</p><p>核心对象：</p><ul><li>Channel （通道）</li><li>Buffer （缓冲）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FilterAndInterceptor</title>
      <link href="/2017/11/03/Filter&amp;Interceptor/"/>
      <url>/2017/11/03/Filter&amp;Interceptor/</url>
      
        <content type="html"><![CDATA[<h3 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h3><h3 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h3><p>​    依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤。但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据。</p><p><strong>比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等</strong></p><h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><p>​    依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理</p><h3 id="过滤器和拦截器的区别："><a href="#过滤器和拦截器的区别：" class="headerlink" title="过滤器和拦截器的区别："></a>过滤器和拦截器的区别：</h3><p>​        ①拦截器是基于java的反射机制的，而过滤器是基于函数回调。</p><p>​        ②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</p><p>​        ③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</p><p>​        ④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</p><p>​        ⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p><p>​        ⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p><h4 id="过滤器主要代码实现："><a href="#过滤器主要代码实现：" class="headerlink" title="过滤器主要代码实现："></a>过滤器主要代码实现：</h4><pre class=" language-Java"><code class="language-Java">    @Override    public void init(FilterConfig filterConfig) throws ServletException {        }    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    }    @Override    public void destroy() {    }</code></pre><h4 id="拦截器主要实现代码："><a href="#拦截器主要实现代码：" class="headerlink" title="拦截器主要实现代码："></a>拦截器主要实现代码：</h4><pre class=" language-Java"><code class="language-Java">  @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //System.out.println("拦截器执行了----前1");        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        //System.out.println("拦截器执行了----后1");        //request.getRequestDispatcher("/error.jsp").forward(request,response);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        //System.out.println("拦截器执行了----最后1");    }</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。（理解：就是一堆字母中取一个B）</p></li><li><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。（理解：就是一堆字母中，干预他，通过验证的少点，顺便干点别的东西）</p></li></ol><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>javax.servlet.ServletContextListener接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁</p><p>主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等</p><p>在javax.servlet.ServletContextListener接口中定义了2种方法：</p><ul><li>void contextInitialized(ServletContextEvent sce) 监听器的初始化</li><li>void contextDestroyed(ServletContextEvent sce) 监听器销毁</li></ul><pre class=" language-Java"><code class="language-Java">package com.cn.util;  import javax.servlet.ServletContextEvent;  import javax.servlet.ServletContextListener;  public class ServletContextListener implements ServletContextListener{   //监听器的初始化  @Override  public void contextInitialized(ServletContextEvent sce) {          System.out.println("监听器ServletContextListener初始化");      }   //监听器的销毁  @Override  public void contextDestroyed(ServletContextEvent sce) {          System.out.println("监听器ServletContextListener销毁");      }  } </code></pre><p>注：项目启动时，先启动监听器，再启动过滤器。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。</li><li>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。</li><li>监听器（Listener）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FilterAndInterceptor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
