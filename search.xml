<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/06/09/Ajax/"/>
      <url>/2019/06/09/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Ajax-json"><a href="#Ajax-json" class="headerlink" title="Ajax+json"></a>Ajax+json</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>​    在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点</p><h4 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h4><ol><li>需要测试浏览器的支持</li><li>网页的后退功能是失效的，需要明显的提示用户“数据已更新”</li><li>手机设备，支持不是很友好</li></ol><h4 id="对象（重要）"><a href="#对象（重要）" class="headerlink" title="对象（重要）"></a>对象（重要）</h4><ol><li><h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><p>提供客户端同HTTP服务器通讯的协议</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"MSXML2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>指定当readyState属性改变时的事件处理句柄</p><pre class=" language-JS"><code class="language-JS">var xmlhttp=null;function PostOrder(xmldoc){  var xmlhttp = new ActiveXObject("Msxml2.XMLHTTP.5.0");  xmlhttp.Open("POST", "http://myserver/orders/processorder.asp", false);   xmlhttp.onreadystatechange= HandleStateChange;  xmlhttp.Send(xmldoc);  myButton.disabled = true;}function HandleStateChange(){  if (xmlhttp.readyState == 4)  {    myButton.disabled = false;    alert("Result = " + xmlhttp.responseXML.xml);  }}</code></pre></li><li><h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>返回当前请求的http状态码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>常用状态码以及含义：</p><ol><li>404  没找到页面(not found)</li><li>403  禁止访问(forbidden)</li><li>500  内部服务器出错(internal service error)</li><li>200  一切正常(ok)</li><li>304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 )</li></ol></li><li><h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>返回XMLHTTP请求的当前状态</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> XmlHttp<span class="token punctuation">;</span>XmlHttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   XmlHttp<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> doHttpReadyStateChange<span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">doHttpReadyStateChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>XmlHttp<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>备注：</p><p>| 0 (未初始化)   |        对象已建立，但是尚未初始化（尚未调用open方法）        |<br>| ————– | :———————————————————-: |<br>| 1 (初始化)     |                 对象已建立，尚未调用send方法                 |<br>| 2 (发送数据)   |          send方法已调用，但是当前的状态及http头未知          |<br>| 3 (数据传送中) | 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 |<br>| 4 (完成)       | 数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据 |</p></li><li><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>创建一个新的http请求，并指定此请求的方法、URL以及验证信息</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> book <span class="token operator">=</span> xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span><span class="token function">selectSingleNode</span><span class="token punctuation">(</span><span class="token string">"//book[@id='bk101']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>open()语法：</p><pre class=" language-js"><code class="language-js">oXMLHttpRequest<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>bstrMethod<span class="token punctuation">,</span> bstrUrl<span class="token punctuation">,</span> varAsync<span class="token punctuation">,</span> bstrUser<span class="token punctuation">,</span> bstrPassword<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、bstrMethod</p><pre><code>http方法，例如：POST、GET、PUT及PROPFIND。大小写不敏感。</code></pre><p>​     <strong>如果用 POST 请求向服务器发送数据，需要将“Content-type” 的首部设置为“application/x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经 符合URL编码了</strong></p><pre class=" language-js"><code class="language-js">ajax<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、bstrUrl</p><pre><code>请求的URL地址，可以为绝对地址也可以为相对地址。 </code></pre><p>3、varAsync[可选]</p><pre><code>布尔型，指定此请求是否为异步方式，默认为true。如果为真，当状态改变时会调用onreadystatechange属性指定的回调函数。 </code></pre><p>4、bstrUser[可选]</p><pre><code>如果服务器需要验证，此处指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。 </code></pre><p>5、bstrPassword[可选]</p><pre><code>验证信息中的密码部分，如果用户名为空，则此值将被忽略。 </code></pre></li><li><h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>发送请求到http服务器并接收回应</p><pre class=" language-js"><code class="language-js">xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令</p><p>2、data：将要传递给服务器的字符串。</p><p>3、若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null);</p><p>4、当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null</p></li></ol><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><h4 id="方式1（利用js原生）"><a href="#方式1（利用js原生）" class="headerlink" title="方式1（利用js原生）"></a>方式1（利用js原生）</h4><pre class=" language-js"><code class="language-js"> $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span><span class="token string">"post"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求方式</span>        url<span class="token punctuation">:</span><span class="token string">"data.jsp"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求地址</span>        data<span class="token punctuation">:</span>params<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//传输的数据，参数</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//服务器返回的话（数据）</span>        <span class="token keyword">var</span> jdata <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//data.trim()是去除返回数据的空格</span>        jdata <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token operator">+</span> jdata <span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="方式2（利用jQuery）"><a href="#方式2（利用jQuery）" class="headerlink" title="方式2（利用jQuery）"></a>方式2（利用jQuery）</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> object <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">parseJSON</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/06/09/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h5 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h5><ol><li>资源的位置不能随意更改</li><li>需要使用../进行文件夹的跳出，使用比较麻烦</li></ol><h5 id="绝对路径-开发常用"><a href="#绝对路径-开发常用" class="headerlink" title="绝对路径(开发常用)"></a>绝对路径(开发常用)</h5><p>​         /虚拟项目名/项目资源路径</p><p>​        注意：在jsp中资源的第一个/表示的是服务器目录，相当于：localhost:8080</p><h5 id="使用jsp中的全局路径声明"><a href="#使用jsp中的全局路径声明" class="headerlink" title="使用jsp中的全局路径声明"></a>使用jsp中的全局路径声明</h5><pre class=" language-Java"><code class="language-Java"><%    String path = request.getContextPath();    String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>base href<span class="token operator">=</span><span class="token string">"&lt;%=basePath%>"</span><span class="token operator">></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A/"/>
      <url>/2019/06/09/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<p>面试题总结：</p><h4 id="1、Byte的取值范围（-128【-2-7】——–127【2-7-1】）"><a href="#1、Byte的取值范围（-128【-2-7】——–127【2-7-1】）" class="headerlink" title="1、Byte的取值范围（-128【-2^7】——–127【2^7-1】）"></a>1、Byte的取值范围（-128【-2^7】——–127【2^7-1】）</h4><h4 id="2、-amp-amp-与-amp-的区别，-与-的区别"><a href="#2、-amp-amp-与-amp-的区别，-与-的区别" class="headerlink" title="2、&amp;&amp;与&amp;的区别，||与|的区别"></a>2、&amp;&amp;与&amp;的区别，||与|的区别</h4><p>​    &amp;&amp;和&amp;都是表示与，区别是&amp;&amp;只要第一个条件不满足，后面条件就不再判断。而&amp;要对所有的条件都进行判断</p><p>​    ||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断</p><h4 id="3、“”与null的区别"><a href="#3、“”与null的区别" class="headerlink" title="3、“”与null的区别"></a>3、“”与null的区别</h4><p>​    “”是有地址但里面的内容是空的</p><p>​    null是没有地址的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/06/09/%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1、String-StringBuffer和StringBuilder的区别是什么？String-为什么是不可变的"><a href="#1、String-StringBuffer和StringBuilder的区别是什么？String-为什么是不可变的" class="headerlink" title="1、String StringBuffer和StringBuilder的区别是什么？String 为什么是不可变的"></a>1、String StringBuffer和StringBuilder的区别是什么？String 为什么是不可变的</h3><p>String：字符串常量</p><p>StringBuffer：字符串变量（线程安全）</p><p>StringBuilder：字符串变量（线程不安全）</p><h4 id="可变性："><a href="#可变性：" class="headerlink" title="可变性："></a>可变性：</h4><p>简单的来说：String与StringBuffer的主要区别是String是不可变的对象，因为每次改变String类型的时候，其实是新生成了一个新的String对象，然后将指针指向新的String对象，所以经常需要修改的String对象此时就不建议使用String了，每次改变的时候都会对系统性能产生影响。</p><p>最重要的是当内存中对象变得越来越多时，JVM的GC就开始工作，造成系统性能下降。</p><p>而StringBuffer是对此对象本身进行修改操作，不生成新的对象。所以在一般情况下，推荐使用StringBuffer。r</p><p>注意在特殊情况下：String对象的字符串拼接被JVM解释成了StringBuffer对象的拼接，而这个时候String的效率是远远比StringBuffer快的：</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">" This is test "</span><span class="token operator">+</span> <span class="token string">" String  "</span><span class="token operator">+</span> <span class="token string">" Speed eg "</span><span class="token punctuation">;</span>StringBuffer s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">" This is test "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span> <span class="token string">" String  "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" Speed eg "</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个时候JVM会把s1当成</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">" This is test String Speed eg "</span><span class="token punctuation">;</span></code></pre><p>来处理的。</p><p>但是需要注意的是如果你此时的s1对象是这样的</p><pre class=" language-java"><code class="language-java">String S2 <span class="token operator">=</span> <span class="token string">"This is"</span><span class="token punctuation">;</span>String S3 <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>String S4 <span class="token operator">=</span> <span class="token string">"String Speed eg"</span><span class="token punctuation">;</span>String S1 <span class="token operator">=</span> S2 <span class="token operator">+</span>S3 <span class="token operator">+</span> S4<span class="token punctuation">;</span></code></pre><p>这个时候JVM就会规矩的按照原始方法来处理。</p><h4 id="String为什么是不可变的"><a href="#String为什么是不可变的" class="headerlink" title="String为什么是不可变的"></a><strong>String为什么是不可变的</strong></h4><p>String和StringBuffer都是final类，他们生成的对象在堆中都是不可变的，在他们内部都是靠属性char数组实现的。</p><p>那为什么StringBuffer可以在对象中追加字符串呢？因为String中的char数组是final的，也就是常量，是不可改变的，而StringBuffer继承自抽象类AbstractStringBuilder，他的内部实现靠他的父类完成，AbstractStringBuilder内的char数组是变量，可以用append追加。</p><p>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，此抽象类实现Appendable接口因此可追加<br>（在JDK 6.0 API中StringBuilder和Stringbuffer写着都继承自Object 而且在他的API中找不到AbstractStringBuilder类）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/session%E5%92%8Ccookie/"/>
      <url>/2019/06/09/session%E5%92%8Ccookie/</url>
      
        <content type="html"><![CDATA[<h3 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/JDBC/"/>
      <url>/2019/06/09/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h5 id="全称"><a href="#全称" class="headerlink" title="全称"></a>全称</h5><p>Java DataBase Connection（Java 数据库连接）</p><h5 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h5><p>JDBC API 使用 Java 的反射机制来实现 Java 程序和 JDBC 驱动的松耦合</p><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><ol><li><p>Statement接口</p></li><li><p>ResultSet接口</p></li><li><p>PreparedStatement接口</p><ul><li>表示预编译的 SQL 语句的对象</li><li>SQL 语句被预编译并存储在 <code>PreparedStatement</code> 对象中。然后可以使用此对象多次<strong>高效</strong>地执行该语句</li></ul></li></ol><h5 id="PreparedStatement接口相比Statement接口的优点"><a href="#PreparedStatement接口相比Statement接口的优点" class="headerlink" title="PreparedStatement接口相比Statement接口的优点"></a>PreparedStatement接口相比Statement接口的优点</h5><ol><li><p>参数设置<br>Statement 需要进行字符串拼接，可读性和维护性比较差<br>PreparedStatement 使用参数设置，可读性好，不易犯错</p></li><li><p>性能表现</p><p>PreparedStatement有预编译机制，性能比Statement更快</p></li><li><p>防止SQL注入式攻击</p></li></ol><h5 id="execute与executeUpdate的区别"><a href="#execute与executeUpdate的区别" class="headerlink" title="execute与executeUpdate的区别"></a>execute与executeUpdate的区别</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>​    都可以执行增加，删除，修改</p><p>不同点</p><ol><li><p>execute可以执行查询语句，然后通过getResultSet，把结果集取出来；</p><p>executeUpdate不能执行查询语句</p></li><li><p>execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update；<br>executeUpdate返回的是int，表示有多少条数据受到了影响</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/09/IO%E4%B8%8ENIO/"/>
      <url>/2019/06/09/IO%E4%B8%8ENIO/</url>
      
        <content type="html"><![CDATA[<h2 id="IO与NIO"><a href="#IO与NIO" class="headerlink" title="IO与NIO"></a>IO与NIO</h2><h5 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h5><h5 id="1、IO流的分类"><a href="#1、IO流的分类" class="headerlink" title="1、IO流的分类"></a>1、IO流的分类</h5><ul><li>按照流向分类【输入流、输出流】</li><li>按照操作单元划分【字节流、字符流】</li><li>按照流的角色划分【节点流、处理流】</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2018/09/07/MySQL/"/>
      <url>/2018/09/07/MySQL/</url>
      
        <content type="html"><![CDATA[<h4 id="看得见的行和列，看不见的索引，看错的分组（MySQL感想）"><a href="#看得见的行和列，看不见的索引，看错的分组（MySQL感想）" class="headerlink" title="看得见的行和列，看不见的索引，看错的分组（MySQL感想）"></a>看得见的行和列，看不见的索引，看错的分组（MySQL感想）</h4><h4 id="行是物理存在的，而分组是逻辑存在的。"><a href="#行是物理存在的，而分组是逻辑存在的。" class="headerlink" title="行是物理存在的，而分组是逻辑存在的。"></a>行是物理存在的，而分组是逻辑存在的。</h4><p>一行数据和一列数据都能被人们感知，一行数据会携带一个主键；而一列数据，不仅有列名，还有列的类型。</p><p>看的见的东西很重要，但是看不见的东西也同样重要，甚至看错的东西更重要。这个人生哲理放在数据库里面，同样成立</p><p>在一次测试种，10000 条记录的数据表中，查找一次平均需要 5000 次比较，而在使用了索引的表中只需要 14 次。</p><p>10000 对 14 的对比</p><h4 id="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"><a href="#索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。" class="headerlink" title="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"></a>索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。</h4><ol><li>索引占用一定的磁盘空间，就像新华字典有目录便要比没有目录的厚一点</li><li>索引大大减缓了插入和删数据的效率，因为每次插入都需要更新索引，一个表拥有的索引越多，进行写操作时平均性能就急剧下降</li></ol><p>数据分组用来将数据分为多个逻辑组，从而可以对每个组进行聚合运算，使用方式为：GROUP BY分组字段。分组语句必须和聚合函数一起使用，GROUP BY子句负责将数据分成逻辑组，而聚函数则对每一个组进行统计计算。</p><p>虽然GROUP BY子句常常和聚合函数起使用，不过GROUP BY子句并不是不能离开聚合函数而单独使用的</p><h4 id="数据分组有以下三大特点"><a href="#数据分组有以下三大特点" class="headerlink" title="数据分组有以下三大特点"></a>数据分组有以下三大特点</h4><ol><li><h5 id="分组与聚合函数"><a href="#分组与聚合函数" class="headerlink" title="分组与聚合函数"></a>分组与聚合函数</h5><p>要分组的所有列都必须位于 GROUP BY子句的列名列表中，也就是没有出现在GROUP BY子句中的列(聚合函数除外)是不能放到SELECET语句后的列名列表中的。比如下面的SQL语句是错误的：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age, salary FROM t_employee GROUP BY age;</code></pre><p>道理非常简单，采用分组以后的查询结果集是以分组形式提供的，由于每组中人员的工资都不样，所以就不存在能够统代表本组工资水平的salary字段了，所以上面的SQL语句是错误的。不过每组中员工的平均工资却能够统一代表本组工水平，所以可以对Salary使用聚合函数，下面的SQL语句则是正确的：</p><pre><code>SELECT age, AVG(salary) FROM t_Employee GROUP BY age;</code></pre></li><li><h5 id="多级数据分组"><a href="#多级数据分组" class="headerlink" title="多级数据分组"></a>多级数据分组</h5><p>GROUP BY子句中可以指定多个列，只需要将多个列的列名用逗号隔开即。指定多个分组规则以后，数据库系统将按照定义的分组顺序来对数据进行逐分组。首先按照第一个分组列进行分组，然后在每个小组内按照第一个分组列行再次分组…逐层分组，从而实现“组中组”的效果，而查询的结果集是以末一级分组来进行输出的。比如下面的SQL语句将会列出所有分公司的所有门的情况：</p><pre class=" language-mysql"><code class="language-mysql">SELECT subcompany, department FROM t_employee GROUP BY subcompany, department;</code></pre></li><li><h5 id="数据分组特点三：数据分组过滤使用HAVING语句"><a href="#数据分组特点三：数据分组过滤使用HAVING语句" class="headerlink" title="数据分组特点三：数据分组过滤使用HAVING语句"></a>数据分组特点三：数据分组过滤使用HAVING语句</h5><p>有的时候需要对部分分组进行过滤，比如只检索人数大于1的年龄段，有的开发人员会使用下面的SQL语句：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age where count(*) > 1 ;</code></pre><p>在数据库系统中执行上面的SQL语句时，数据库系统会提示语法错误。这是因为聚合函数不能在WHERE语句中使用，必须使用HAVING子句来代替，比如:</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age having count(*) > 1 ;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传项目到Github</title>
      <link href="/2018/09/07/Git%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0Github/"/>
      <url>/2018/09/07/Git%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0Github/</url>
      
        <content type="html"><![CDATA[<h3 id="Git上传项目到Github"><a href="#Git上传项目到Github" class="headerlink" title="Git上传项目到Github"></a>Git上传项目到Github</h3><h4 id="0、新建文件夹"><a href="#0、新建文件夹" class="headerlink" title="0、新建文件夹"></a>0、新建文件夹</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036553006.png" alt="1559036553006"></p><h4 id="1、在此文件夹右键Git-Bash-Here，输入命令"><a href="#1、在此文件夹右键Git-Bash-Here，输入命令" class="headerlink" title="1、在此文件夹右键Git Bash Here，输入命令"></a>1、在此文件夹右键Git Bash Here，输入命令</h4><pre class=" language-Java"><code class="language-Java">git init</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036600072.png" alt="1559036600072"></p><p>此步操作为初始化git工作区间</p><h4 id="2、将需要上传的项目复制到工作区间"><a href="#2、将需要上传的项目复制到工作区间" class="headerlink" title="2、将需要上传的项目复制到工作区间"></a>2、将需要上传的项目复制到工作区间</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036752091.png" alt="1559036752091"></p><h4 id="3、输入命令git-status-查看git工作区间的文件变化"><a href="#3、输入命令git-status-查看git工作区间的文件变化" class="headerlink" title="3、输入命令git status 查看git工作区间的文件变化"></a>3、输入命令git status 查看git工作区间的文件变化</h4><pre><code>git status</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036885875.png" alt="1559036885875"></p><h4 id="4、输入命令git-add-将文件加入到暂存区"><a href="#4、输入命令git-add-将文件加入到暂存区" class="headerlink" title="4、输入命令git add . 将文件加入到暂存区"></a>4、输入命令git add . 将文件加入到暂存区</h4><pre><code>git add .</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036995464.png" alt="1559036995464"></p><h4 id="5、将文件提交到本地仓库"><a href="#5、将文件提交到本地仓库" class="headerlink" title="5、将文件提交到本地仓库"></a>5、将文件提交到本地仓库</h4><pre><code>git commit -m &quot;the first commit&quot;</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037091035.png" alt="1559037091035"></p><h4 id="6、在Github种新建仓库"><a href="#6、在Github种新建仓库" class="headerlink" title="6、在Github种新建仓库"></a>6、在Github种新建仓库</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037194341.png" alt="1559037194341"></p><p>7、复制仓库链接（https链接）</p><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037237509.png" alt="1559037237509"></p><h4 id="8、将本地仓库关联到Github仓库"><a href="#8、将本地仓库关联到Github仓库" class="headerlink" title="8、将本地仓库关联到Github仓库"></a>8、将本地仓库关联到Github仓库</h4><pre><code>git remote add origin https://...</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037332932.png" alt="1559037332932"></p><h4 id="9、将本地仓库同步到GitHub仓库"><a href="#9、将本地仓库同步到GitHub仓库" class="headerlink" title="9、将本地仓库同步到GitHub仓库"></a>9、将本地仓库同步到GitHub仓库</h4><pre><code>git push origin master</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037744888.png" alt="1559037744888"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java包装类</title>
      <link href="/2018/09/07/%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2018/09/07/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h5 id="基本类型，引用类型"><a href="#基本类型，引用类型" class="headerlink" title="基本类型，引用类型"></a>基本类型，引用类型</h5><h5 id="以对象的形式保存基本类型的值，Java提供了对应的包装类"><a href="#以对象的形式保存基本类型的值，Java提供了对应的包装类" class="headerlink" title="以对象的形式保存基本类型的值，Java提供了对应的包装类"></a>以对象的形式保存基本类型的值，Java提供了对应的包装类</h5><table><thead><tr><th><strong>Byte byte</strong></th><th><strong>Short short</strong></th><th><strong>Integer int</strong></th><th><strong>Long long</strong></th></tr></thead><tbody><tr><td><strong>Float float</strong></td><td><strong>Double double</strong></td><td><strong>Character char</strong></td><td><strong>Boolean boolean</strong></td></tr></tbody></table><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>Integer iObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所有的类都是Object类的子孙</p><p>所有的对象一定是Object的子类对象</p><p>所有的对象可以赋给Object类型的引用类型</p><ul><li>一方面出于性能方面的考虑，Java为数值使用基本类型，而不是对象。基本类型不是对象层次的组成部分，它们不继承Object</li><li>另一方面有时需要创建表示基本类型的对象，例如集合类只处理对象。为了在对象中存储基本类型，需要将基本类型包装到一个类中，为此Java为8种基本数据类型分别提供了对应的包装类。本质上这些类将基本类型包装到一个类中，因此通常将它们称为类型包装器。包装器类位于Java.lang包中</li></ul><h5 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h5><p>举例：</p><pre class=" language-Java"><code class="language-Java">int i = 100;String str2 = Integer.toString(i);     //第一种方法：利用静态的toString()方法String str3 = String.valueOf(i);       //第二种方法：利用String类中的valueOf()方法String str4 = i + "";                 //第三种方法：投机取巧的方法Integer objI = i;                      //先自动装箱String str1 = objI.toString();         //第四种方法：先装箱，再利用toString()方法System.out.println(str1);System.out.println(str2);System.out.println(str3);System.out.println(str4);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis总结</title>
      <link href="/2018/09/07/MyBatis%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/07/MyBatis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h4><h5 id="配置文件与映射文件"><a href="#配置文件与映射文件" class="headerlink" title="配置文件与映射文件"></a>配置文件与映射文件</h5><h5 id="MyBatisCRUD操作"><a href="#MyBatisCRUD操作" class="headerlink" title="MyBatisCRUD操作"></a>MyBatisCRUD操作</h5><h5 id="ResultType与ResultMap区别"><a href="#ResultType与ResultMap区别" class="headerlink" title="ResultType与ResultMap区别"></a>ResultType与ResultMap区别</h5><p>实体类与表中字段不一致时</p><ol><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致，这样就可以表的字段名和实体类的属性名一一对应上了，这种方式是通过在sql语句中定义别名来解决字段名和属性名的映射关系的。</li><li>通过<resultmap>来映射字段名和实体类属性名的一一对应关系。这种方式是使用MyBatis提供的解决方式来解决字段名和属性名的映射关系的</resultmap></li></ol><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>​    if，choose (when, otherwise)，trim (where, set)，foreach</p><h5 id="一对一，一对多，多对多高级映射（association-collection）"><a href="#一对一，一对多，多对多高级映射（association-collection）" class="headerlink" title="一对一，一对多，多对多高级映射（association,collection）"></a>一对一，一对多，多对多高级映射（association,collection）</h5><ol><li>一对一关联，使用assacation标签</li><li>一对多关联，使用collection标签。collection标签来解决一对多的关联查询，ofType属性指定集合中元素的对象类型         </li></ol><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p>​    mybatis默认没有开启延迟加载，需要在MyBaits-Config.xml中setting配置</p><p>​    使用association、collection能实现表间关联，association、collection也具备延迟加载功能延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><h5 id="一级缓存、二级缓存"><a href="#一级缓存、二级缓存" class="headerlink" title="一级缓存、二级缓存"></a>一级缓存、二级缓存</h5><ol><li>一级缓存默认开启，作用域一个sqlSession中，两个查询之后第二次查询会在缓存之中查找，提交查找效率，如果进行commit()（insert,update,delete）操作，则清空缓存。</li><li>二级缓存默认开启，需要在xml文件中配置，其作用域为一个Mapper，即namespace，所以需要在对应的xml文件中进行配置。而且缓存可自定义存储源（Redis,EhCache,MemcCache）</li></ol><h5 id="分页、批量"><a href="#分页、批量" class="headerlink" title="分页、批量"></a>分页、批量</h5><ol><li>mybatis的分页功能，可以自己利用mysql代码实现，也可以利用mybatis分页插件,如pageHelper</li><li>批量则依赖于SQL语句</li></ol><h5 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h5>]]></content>
      
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2018/09/07/%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/09/07/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h5 id="以下4种情况，finally不会被执行"><a href="#以下4种情况，finally不会被执行" class="headerlink" title="以下4种情况，finally不会被执行"></a>以下4种情况，finally不会被执行</h5><ol><li>在finally语句块中发生了异常</li><li>在前面的代码块中使用了System.exit()退出程序</li><li>程序所在的线程死亡</li><li>关闭CPU</li></ol><h5 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h5><h6 id="runtime-Exception"><a href="#runtime-Exception" class="headerlink" title="runtime Exception"></a>runtime Exception</h6><pre><code> 1、 java.lang.ArrayIndexOutOfBoundsException</code></pre><p>​    数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出</p><p>​    2、java.lang.ArithmeticException</p><p>​    算术条件异常。譬如：整数除零等</p><p>​    3、java.lang.NullPointerException</p><p>​    空指针异常。当应用试图在要求使用对象的地方使用了 null 时，抛出该异常。譬如：调用 null 对象的实例方法、访问 null 对象的属性、计算 null 对象的长度、使用 throw 语句抛出 null 等等</p><p>​    4、java.lang.ClassNotFoundException</p><p>​    找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历 CLASSPAH 之后找不到对应名称的 class 文件时，抛出该异常</p><p>   5、java.lang.NegativeArraySizeException  数组长度为负异常</p><p>   6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</p><p>   7、java.lang.SecurityException 安全性异常</p><p>   8、java.lang.IllegalArgumentException 非法参数异常</p><h6 id="IOException"><a href="#IOException" class="headerlink" title="IOException"></a>IOException</h6><ol><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException   文件已结束异常</li><li>FileNotFoundException   文件未找到异常</li></ol><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ol><li>ClassCastException    类型转换异常类</li><li>ArrayStoreException  数组中包含不兼容的值抛出的异常</li><li>SQLException   操作数据库异常类</li><li>NoSuchFieldException   字段未找到异常</li><li>NoSuchMethodException   方法未找到抛出的异常</li><li>NumberFormatException    字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException  不允许访问某类异常</li><li>InstantiationException  当应用程序试图使用 Class 类中的 newInstance() 方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ol><h5 id="throw与throws的比较"><a href="#throw与throws的比较" class="headerlink" title="throw与throws的比较"></a>throw与throws的比较</h5><ol><li>throws 出现在方法函数头；而 throw 出现在函数体</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象</li><li>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2018/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="一、线程与进程的5个阶段"><a href="#一、线程与进程的5个阶段" class="headerlink" title="一、线程与进程的5个阶段"></a>一、线程与进程的5个阶段</h5><p>创建、就绪、运行、阻塞、终止</p><h5 id="二、实现多线程的方法（3种）"><a href="#二、实现多线程的方法（3种）" class="headerlink" title="二、实现多线程的方法（3种）"></a>二、实现多线程的方法（3种）</h5><ol><li>扩展java.lang.Thread类</li><li>实现java.lang.Runable接口</li><li>实现Callable接口，并与 Future、线程池结合使用</li></ol><h5 id="三、分类介绍"><a href="#三、分类介绍" class="headerlink" title="三、分类介绍"></a>三、分类介绍</h5><ol><li><h6 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Thread1</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"运行："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Thread1 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"jordan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread1 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"kobe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><p>jordan运行：0<br>kobe运行：0<br>kobe运行：1<br>kobe运行：2<br>jordan运行：1<br>kobe运行：3<br>jordan运行：2<br>kobe运行：4<br>jordan运行：3<br>jordan运行：4</p><blockquote><p>注意：</p><ol><li>start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的</li><li>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程</li><li>Thread.sleep() 方法调用目的是不让当前线程独自霸占该进程所获取的 CPU 资源，以留出一定时间给其他线程执行的机会</li><li>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的</li><li>start 方法重复调用的话，会出现 java.lang.IllegalThreadStateException 异常</li></ol></blockquote><h6 id="2-实现Runable接口"><a href="#2-实现Runable接口" class="headerlink" title="2.实现Runable接口"></a>2.实现Runable接口</h6><pre class=" language-Java"><code class="language-Java">package com.test.thread;public class Thread2 implements Runnable {    private String name;    public Thread2(String name) {        super();        this.name = name;    }    @Override    public void run() {        // TODO Auto-generated method stub        for (int i = 0; i < 5; i++) {            System.out.println(name+"运行："+i);        }        try {            Thread.sleep((long) (Math.random()*10));        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}//测试类package com.test.thread;public class Test2 {    public static void main(String[] args) {        // TODO Auto-generated method stub        new Thread(new Thread2("jordan")).start();        new Thread(new Thread2("kobe")).start();    }}</code></pre><h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><p>如果一个类继承 Thread，则不适合资源共享。但是如果实现了 Runable 接口的话，则很容易的实现资源共享</p><h6 id="总结：（实现Runable接口继承Thread的优点）"><a href="#总结：（实现Runable接口继承Thread的优点）" class="headerlink" title="总结：（实现Runable接口继承Thread的优点）"></a>总结：（实现Runable接口继承Thread的优点）</h6><ol><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免Java单继承的缺点</li><li>增加程序的健壮性，代码可以被多个线程共享，代码和数据共享</li><li>线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</li></ol><blockquote><p>注意：main 方法其实也是一个线程。在 java 中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到 CPU 的资源</p></blockquote><h5 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h5><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p><p>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>（一）、等待阻塞：运行的线程执行 wait() 方法，JVM 会把该线程放入等待池中。(wait 会释放持有的锁)</p><p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中。</p><p>（三）、其他阻塞：运行的线程执行 sleep() 或 join() 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。（注意, sleep 是不会释放持有的锁）</p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。</p><h5 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h5><ol><li><p>调整线程优先级：Java 线程有优先级，优先级高的线程会获得较多的运行机会</p><p>Java 线程的优先级用整数表示，取值范围是 1~10，Thread 类有以下三个静态常量：</p><blockquote><pre class=" language-Java"><code class="language-Java"></code></pre><p>static int MAX_PRIORITY</p><pre><code>   //线程可以具有的最高优先级，取值为10。</code></pre><p>static int MIN_PRIORITY</p><pre><code>   //线程可以具有的最低优先级，取值为1。</code></pre><p>static int NORM_PRIORITY</p><pre><code>   //分配给线程的默认优先级，取值为5。</code></pre><pre><code></code></pre></blockquote></li></ol><p>Thread 类的 setPriority() 和 getPriority() 方法分别用来设置和获取线程的优先级</p><p>每个线程都有默认的优先级。主线程的默认优先级为 Thread.NORM_PRIORITY</p><p>线程的优先级有继承关系，比如 A 线程中创建了 B 线程，那么 B 将和 A 具有相同的优先级</p><p>JVM 提供了 10 个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用 Thread 类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式</p></li><li><p>线程睡眠（sleep()）:Thread()的方法，使线程转到阻塞状态，结束后，线程转入就绪（Runable）状态</p></li><li><p>线程等待（wait()）:Object()的方法，使线程等待，直到其他线程调用此对象的notify(all)()方法时方可唤醒此线程</p></li><li><p>线程让步（yield()）:Thread()的方法，暂停正在执行的线程，将执行让给有优先级相同或者更高的线程执行</p></li><li><p>线程加入（join()）:Thread()的方法，在当前线程调用其他线程的join()方法，当前线程转入阻塞状态，直到被调用的线程运行完毕，当前线程由阻塞状态转为就绪状态</p></li><li><p>线程唤醒（notify()）:Object()的方法，</p></li></ol><p>注意：Thread 中 suspend() 和 resume() 两个方法在 JDK1.5 中已经废除，不再介绍。因为有死锁倾向</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multithreading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap与ConcurrentHashMap</title>
      <link href="/2018/09/07/HashMap%E4%B8%8EConcurrentHashMap/"/>
      <url>/2018/09/07/HashMap%E4%B8%8EConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h3><h5 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h5><p><img src="C:\Users\Goffy\Desktop\继承图谱\HashMap.jpg" alt></p><h5 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h5><p>JDK1.8之前：数组+链表（散列集）</p><p>JDK1.8之后：数组+链表（散列集）+红黑二叉树</p><h5 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891042167.png" alt="1557891042167"></p><ol><li>序列化机制验证版本</li><li>初始容量</li><li>最大容量，2的31次方</li><li>默认装载因子</li><li>当添加一个元素被添加到有至少TREEIFY_THRESHOLD节点的桶中，桶中链表将转化为链表</li><li>同上，不过是将树形结构转化为链表</li><li>桶可能被转化成树形结构的最小容量</li></ol><h6 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h6><pre class=" language-Java"><code class="language-Java">private static final long serialVersionUID = 362498820763181265L;static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16static final int MAXIMUM_CAPACITY = 1 << 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891742915.png" alt="1557891742915"></p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557892222219.png" alt="1557892222219"></p><h5 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h5><ul><li>无序、允许为Null、非同步</li><li>底层由散列表实现</li><li>初始容量和加载因子对其影响较大</li></ul>]]></content>
      
      
      <categories>
          
          <category> 集合和泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet常见问题</title>
      <link href="/2018/09/07/servlet/"/>
      <url>/2018/09/07/servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><h4 id="处理中文乱码问题"><a href="#处理中文乱码问题" class="headerlink" title="处理中文乱码问题"></a>处理中文乱码问题</h4><h5 id="请求中文乱码解决"><a href="#请求中文乱码解决" class="headerlink" title="请求中文乱码解决"></a>请求中文乱码解决</h5><ol><li>使用String进行数据重新编码</li></ol><pre class=" language-Java"><code class="language-Java">uname = new String(uname.getBytes("iso8859-1"),"utf-8");</code></pre><ol start="2"><li><p>使用公共配置</p><ul><li><p>get方法：</p><p>步骤一：</p><pre class=" language-Java"><code class="language-Java">request.setCharacterEncoding("utf-8");</code></pre><p>步骤二：</p><p>在Tomcat的目录下的conf目录中的修改server.xml文件，在Connector标签中增加useBodyEncodingForURI=”true”</p></li><li><p>post方法：</p><pre class=" language-Java"><code class="language-Java">resp.setContentType("text/html; charset=UTF-8");</code></pre></li></ul></li></ol><h4 id="forward-与-sendRedirect"><a href="#forward-与-sendRedirect" class="headerlink" title="forward 与 sendRedirect"></a>forward 与 sendRedirect</h4><ol><li><p>​    重定向（sendRedirect）</p><pre class=" language-Java"><code class="language-Java">resp.sendRedirect("path");</code></pre><p>​    解决了表单重复提交的问题，以及当前servlet无法提交的问题</p><p>​    特点：</p><ol><li>​    两次请求    两个request对象</li><li>​    浏览器地址栏信息改变</li></ol></li><li><p>请求转发（forward） </p><pre class=" language-Java"><code class="language-Java">req.getRequestDispatcher("path").forward(req, resp);</code></pre><p>​    地址栏信息不改变，会造成频繁请求地址。</p></li><li><p>使用场景：</p><ol><li>如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向</li><li>如果请求被servlet接收后，无法进行处理，建议使用重定向定位到可以处理资源的servlet上</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
