<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBootInit</title>
      <link href="/2019/07/18/SpringBootInit/"/>
      <url>/2019/07/18/SpringBootInit/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是SpringBoot-优点"><a href="#什么是SpringBoot-优点" class="headerlink" title="什么是SpringBoot?(优点)"></a>什么是SpringBoot?(优点)</h4><p>无须依赖外部Servlet容器，使编码变得简单，使配置变得简单，使部署变得简单，使监控变得简单</p><h4 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h4><ol><li><p>自动创建</p><p>通过 STS 快速创建一个Spring Boot项目</p></li><li><p>手动创建</p><ol><li><p>创建Maven项目</p><p>修改pom.xml文件，增加Spring Boot框架的依赖关系及对Web环境的支持</p></li></ol><pre class=" language-Java"><code class="language-Java"> <parent>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-parent</artifactId>        <version>1.5.8.RELEASE</version>    </parent>    ...    <dependencies>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-web</artifactId>        </dependency>    </dependencies></code></pre><ul><li>spring-boot-starter-parent：继承Spring Boot的相关参数</li><li>spring-boot-starter-xxx：代表一个Spring Boot模块</li><li>spring-boot-starter-web：代表Web模块，在这个模块中包含了许多依赖的JAR包</li></ul></li></ol><h4 id="增加程序代码"><a href="#增加程序代码" class="headerlink" title="增加程序代码"></a>增加程序代码</h4><p>在src/main/java目录中增加类com.example.demo.DemoApplication，并增加相应代码</p><p>注意：文件必须以Application结尾</p><pre class=" language-Java"><code class="language-Java">@SpringBootApplication//注解：确认SpringBoot的主入口类public class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><h4 id="集成Tomcat"><a href="#集成Tomcat" class="headerlink" title="集成Tomcat"></a>集成Tomcat</h4><p>SpringBoot内置Tomcat服务</p><p>Spring Boot会自动读取src/main/resources/路径或类路径下/config路径中的application.properties文件或application.yml文件</p><p>读取顺序参考源码：</p><pre class=" language-Java"><code class="language-Java">  <resource>        <filtering>true</filtering>        <directory>${basedir}/src/main/resources</directory>        <includes>          <include>**/application*.yml</include>          <include>**/application*.yaml</include>          <include>**/application*.properties</include>        </includes>      </resource></code></pre><p>可以看出，SpringBoot可以读取${basedir}/src/main/resources下面的任意以yml、yaml或者properties结尾的配置文件，依次覆盖，yml文件更加简便，避免了重复。</p><h4 id="集成Spring-amp-SpringBoot"><a href="#集成Spring-amp-SpringBoot" class="headerlink" title="集成Spring&amp;SpringBoot"></a>集成Spring&amp;SpringBoot</h4><ul><li><p>@ComponentScan注解</p><p>该注解需要注解再入口文件(以Application结尾的含有mainf()方法的文件)</p></li></ul><pre class=" language-Java"><code class="language-Java">@ComponentScan(basePackages = "com.example.demo.controller.BoysController")@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        SpringApplication.run(DemoApplication.class, args);    }}</code></pre><p>默认扫描当前包和子包</p><ul><li><p>增加控制器代码</p><ul><li>@Controller注解</li><li>@RestController注解 （Controller+ResponseBody）</li></ul><pre><code>@Controllerpublic class BoysController {    @RequestMapping(&quot;/index&quot;)    @ResponseBody    public Object index(){        Map map = new HashMap();        map.put(&quot;username&quot;, &quot;张三&quot;);        return map;    }}</code></pre></li><li><p>执行主入口文件：浏览器访问127.0.0.1：8080/index可以看到输出map集合</p></li></ul><h4 id="增加服务层代码"><a href="#增加服务层代码" class="headerlink" title="增加服务层代码"></a>增加服务层代码</h4><p>与mvc完全一致</p><h4 id="集成Mybatis"><a href="#集成Mybatis" class="headerlink" title="集成Mybatis"></a>集成Mybatis</h4><ul><li><p>增加依赖</p><pre class=" language-java"><code class="language-java"> <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>springboot集成mybatis<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>mybatis<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.3</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>springboot集成mysql<span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>mysql<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">8.0</span><span class="token punctuation">.</span><span class="token number">11</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre></li><li><p>配置数据源（yml文件）</p><pre class=" language-java"><code class="language-java">#数据库配置spring<span class="token operator">:</span>  datasource<span class="token operator">:</span>    driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">:</span> com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver    url<span class="token operator">:</span> jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>DBNamew<span class="token operator">?</span>characterEncoding<span class="token operator">=</span>utf8<span class="token operator">&amp;</span>serverTimezone<span class="token operator">=</span>GMT<span class="token operator">%</span>2B8    username<span class="token operator">:</span> root    password<span class="token operator">:</span> <span class="token number">123456</span></code></pre><p>这几种key分别在源码中可以找到</p></li><li><p>扫描Dao接口和开启声明式事务(注解和xml)</p><ul><li><p>注解</p><ul><li>需要在Application主入口文件中增加扫描注解@MapperScan(“com.example.**.dao”)及事务管理@EnableTransactionManagement</li><li>增加Dao代码</li></ul><pre class=" language-Java"><code class="language-Java">public interface indexDao {@Select("select * from t_member where id = #{id}")public Member queryById(Integer id);</code></pre><ul><li>增加实体类</li><li>增加事务注解（ServiceImpl）</li></ul></li><li><p>xml</p><pre class=" language-Java"><code class="language-Java"><mapper namespace="com.example.demo.mapper.BoysMapper">    <select id="queryBoysList" resultType="boys">        select * from boys    </select></mapper></code></pre><ul><li>yml配置</li></ul><pre class=" language-Java"><code class="language-Java">mybatis:  type-aliases-package: com.example.demo.bean  mapper-locations:    - classpath:mapper/*Mapper.xml</code></pre></li></ul></li></ul><h4 id="集成Redis"><a href="#集成Redis" class="headerlink" title="集成Redis"></a>集成Redis</h4><ul><li><p>增加依赖</p><pre class=" language-Java"><code class="language-Java"><!--springboot集成redis-->        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-data-redis</artifactId>        </dependency></code></pre></li><li><p>yml配置</p><pre class=" language-Java"><code class="language-Java">  redis:    host: 127.0.0.1    port: 6379</code></pre></li><li><p>开启Redis服务（windows模拟）</p><p>window安装Redis,启动成功</p><p><img src alt="http://puyu3wzq5.bkt.clouddn.com/0.jpg"></p></li><li><p>编写测试代码</p><pre class=" language-Java"><code class="language-Java">@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class RedisTest {    @Autowired    private RedisTemplate<String,String> redisTemplate;    @Autowired    private BoysMapper boysMapper;    @Test    public void testRedis() throws JsonProcessingException {        //1、从redis中获得数据数据的形式为json形式        String boysListJson = redisTemplate.boundValueOps("boysListsRedis.findAll").get();        //2、判断redis是否含有数据        if (boysListJson == null) {            //3、不存在数据，则从数据库中查找            List<Boys> queryBoysList = boysMapper.queryBoysList();            //3.1、将查询出的数据存放在Redis缓存中            //将list集合转化成json格式 使用jackson进行转换            ObjectMapper objectMapper = new ObjectMapper();            String writeValueAsString = objectMapper.writeValueAsString(queryBoysList);            redisTemplate.boundValueOps("boysListsRedis.findAll").set(boysListJson);            System.out.println("=======从数据库查询的数据=======");        }else {            System.out.println("======从缓存中获得的数据======");        }        //4、将数据打印在控制台        System.out.println(boysListJson);    }}</code></pre><p>第一次打印显示从数据库读取，第二次打印显示从Redis缓存中读取</p></li></ul><h4 id="分布式集成"><a href="#分布式集成" class="headerlink" title="分布式集成"></a>分布式集成</h4><ul><li><p>热部署</p><ul><li><p>增加依赖</p><pre class=" language-Java"><code class="language-Java"><dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-devtools</artifactId>        <optional>true</optional><!-- 这个需要为 true 热部署才有效-->    </dependency></code></pre></li><li><p>IDEA需要打开自动部署，以及Ctrl+Shift+Alt+/快捷键打开when.app.running才可生效</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2019/02/20/Maven/"/>
      <url>/2019/02/20/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven学习"><a href="#Maven学习" class="headerlink" title="Maven学习"></a>Maven学习</h1><h4 id="Maven项目目录说明："><a href="#Maven项目目录说明：" class="headerlink" title="Maven项目目录说明："></a>Maven项目目录说明：</h4><ol><li>根目录：工程名</li><li>src目录：源码</li><li>pom.xml文件：Maven工程的核心控制文件</li><li>main目录：存放主程序</li><li>test目录：存放测试程序</li><li>java目录：存放Java源文件</li><li>resources目录：存放框架与其他工具的配置文件</li></ol><h4 id="为什么遵守："><a href="#为什么遵守：" class="headerlink" title="为什么遵守："></a>为什么遵守：</h4><p>约定&gt;配置&gt;编码</p><h4 id="常用的Maven命令："><a href="#常用的Maven命令：" class="headerlink" title="常用的Maven命令："></a>常用的Maven命令：</h4><ol><li>mvn compile    编译</li><li>mvn clean    清理</li><li>mvn test    测试</li><li>mvn package    打包</li></ol><h4 id="Maven依赖范围（scope）："><a href="#Maven依赖范围（scope）：" class="headerlink" title="Maven依赖范围（scope）："></a>Maven依赖范围（scope）：</h4><ol><li><p>compile</p><ul><li>对主程序是否有效：有效</li><li>对测试程序是否有效：有效</li><li>是否参与打包：参与</li></ul></li><li><p>test</p><ul><li><p>对主程序是否有效：无效</p></li><li><p>对测试程序是否有效：有效</p></li><li><p>是否参与打包：不参与</p></li></ul></li><li><p>provided</p><ul><li><p>对主程序是否有效：有效</p></li><li><p>对测试程序是否有效：有效</p></li><li>是否参与打包：不参与</li><li>是否参与部署：不参与</li></ul></li></ol><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><h4 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a>依赖的传递性：</h4><p>​    优点：可以传递的依赖不必在每个模块下都重复声明，在”最下面“的工程中依赖一次即可</p><p>​    注意：非compile范围的依赖不能传递</p><h4 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a>依赖的排除：</h4><p>​    依赖排除的场合：只对自己起作用</p><h4 id="依赖的原则："><a href="#依赖的原则：" class="headerlink" title="依赖的原则："></a>依赖的原则：</h4><p>作用：解决jar包冲突的问题</p><ul><li>就近原则</li><li>先声明者优先</li></ul><h4 id="统一管理依赖的版本号："><a href="#统一管理依赖的版本号：" class="headerlink" title="统一管理依赖的版本号："></a>统一管理依赖的版本号：</h4><p>​    使用propertier标签声明，各自里面使用${}替换</p><h4 id="依赖的继承："><a href="#依赖的继承：" class="headerlink" title="依赖的继承："></a>依赖的继承：</h4><p>问题：由于test范围的依赖不能传递，所以必然分散在每一个模块中，造成版本不一致</p><p>解决：将test依赖范围的jar包统一提取到”父 “工程中，在子工程中不声明jar包的版本，统一使用”父“工程中的jar包的版本号</p>]]></content>
      
      
      <categories>
          
          <category> Productivity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax&amp;json</title>
      <link href="/2019/02/20/Ajax/"/>
      <url>/2019/02/20/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="Ajax-json"><a href="#Ajax-json" class="headerlink" title="Ajax+json"></a>Ajax+json</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>​    在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点</p><h4 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h4><ol><li>需要测试浏览器的支持</li><li>网页的后退功能是失效的，需要明显的提示用户“数据已更新”</li><li>手机设备，支持不是很友好</li></ol><h4 id="对象（重要）"><a href="#对象（重要）" class="headerlink" title="对象（重要）"></a>对象（重要）</h4><ol><li><h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><p>提供客户端同HTTP服务器通讯的协议</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"MSXML2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//非IE</span><span class="token keyword">var</span> xmlHttpReq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlHttpReq<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlHttpReq<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h5 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h5><p>指定当readyState属性改变时的事件处理句柄</p><pre class=" language-JS"><code class="language-JS">var xmlhttp=null;function PostOrder(xmldoc){  var xmlhttp = new ActiveXObject("Msxml2.XMLHTTP.5.0");  xmlhttp.Open("POST", "http://myserver/orders/processorder.asp", false);   xmlhttp.onreadystatechange= HandleStateChange;  xmlhttp.Send(xmldoc);  myButton.disabled = true;}function HandleStateChange(){  if (xmlhttp.readyState == 4)  {    myButton.disabled = false;    alert("Result = " + xmlhttp.responseXML.xml);  }}</code></pre></li><li><h5 id="status"><a href="#status" class="headerlink" title="status"></a>status</h5><p>返回当前请求的http状态码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>常用状态码以及含义：</p><ol><li>404  没找到页面(not found)</li><li>403  禁止访问(forbidden)</li><li>500  内部服务器出错(internal service error)</li><li>200  一切正常(ok)</li><li>304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 )</li></ol></li><li><h5 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h5><p>返回XMLHTTP请求的当前状态</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> XmlHttp<span class="token punctuation">;</span>XmlHttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   XmlHttp<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> doHttpReadyStateChange<span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   XmlHttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">doHttpReadyStateChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>XmlHttp<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>备注：</p><p>| 0 (未初始化)   |        对象已建立，但是尚未初始化（尚未调用open方法）        |<br>| ————– | :———————————————————-: |<br>| 1 (初始化)     |                 对象已建立，尚未调用send方法                 |<br>| 2 (发送数据)   |          send方法已调用，但是当前的状态及http头未知          |<br>| 3 (数据传送中) | 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 |<br>| 4 (完成)       | 数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据 |</p></li><li><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>创建一个新的http请求，并指定此请求的方法、URL以及验证信息</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span><span class="token string">"http://localhost/books.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> book <span class="token operator">=</span> xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span><span class="token function">selectSingleNode</span><span class="token punctuation">(</span><span class="token string">"//book[@id='bk101']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>open()语法：</p><pre class=" language-js"><code class="language-js">oXMLHttpRequest<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>bstrMethod<span class="token punctuation">,</span> bstrUrl<span class="token punctuation">,</span> varAsync<span class="token punctuation">,</span> bstrUser<span class="token punctuation">,</span> bstrPassword<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、bstrMethod</p><pre><code>http方法，例如：POST、GET、PUT及PROPFIND。大小写不敏感。</code></pre><p>​     <strong>如果用 POST 请求向服务器发送数据，需要将“Content-type” 的首部设置为“application/x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经 符合URL编码了</strong></p><pre class=" language-js"><code class="language-js">ajax<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span><span class="token string">"application/x-www-form-urlencoded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>2、bstrUrl</p><pre><code>请求的URL地址，可以为绝对地址也可以为相对地址。 </code></pre><p>3、varAsync[可选]</p><pre><code>布尔型，指定此请求是否为异步方式，默认为true。如果为真，当状态改变时会调用onreadystatechange属性指定的回调函数。 </code></pre><p>4、bstrUser[可选]</p><pre><code>如果服务器需要验证，此处指定用户名，如果未指定，当服务器需要验证时，会弹出验证窗口。 </code></pre><p>5、bstrPassword[可选]</p><pre><code>验证信息中的密码部分，如果用户名为空，则此值将被忽略。 </code></pre></li><li><h5 id="send"><a href="#send" class="headerlink" title="send"></a>send</h5><p>发送请求到http服务器并接收回应</p><pre class=" language-js"><code class="language-js">xmlhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXObject</span><span class="token punctuation">(</span><span class="token string">"Msxml2.XMLHTTP.3.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost/sample.xml"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>xmlhttp<span class="token punctuation">.</span>responseXML<span class="token punctuation">.</span>xml<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>1、open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令</p><p>2、data：将要传递给服务器的字符串。</p><p>3、若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null);</p><p>4、当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null</p></li></ol><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><h4 id="方式1（利用js原生）"><a href="#方式1（利用js原生）" class="headerlink" title="方式1（利用js原生）"></a>方式1（利用js原生）</h4><pre class=" language-js"><code class="language-js"> $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span><span class="token string">"post"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求方式</span>        url<span class="token punctuation">:</span><span class="token string">"data.jsp"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//请求地址</span>        data<span class="token punctuation">:</span>params<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//传输的数据，参数</span>        success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//服务器返回的话（数据）</span>        <span class="token keyword">var</span> jdata <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//data.trim()是去除返回数据的空格</span>        jdata <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token operator">+</span> jdata <span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="方式2（利用jQuery）"><a href="#方式2（利用jQuery）" class="headerlink" title="方式2（利用jQuery）"></a>方式2（利用jQuery）</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> object <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">parseJSON</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2018/12/29/Thread/"/>
      <url>/2018/12/29/Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="一、线程与进程的5个阶段"><a href="#一、线程与进程的5个阶段" class="headerlink" title="一、线程与进程的5个阶段"></a>一、线程与进程的5个阶段</h5><p>创建、就绪、运行、阻塞、终止</p><h5 id="二、实现多线程的方法（3种）"><a href="#二、实现多线程的方法（3种）" class="headerlink" title="二、实现多线程的方法（3种）"></a>二、实现多线程的方法（3种）</h5><ol><li>扩展java.lang.Thread类</li><li>实现java.lang.Runable接口</li><li>实现Callable接口，并与 Future、线程池结合使用</li></ol><h5 id="三、分类介绍"><a href="#三、分类介绍" class="headerlink" title="三、分类介绍"></a>三、分类介绍</h5><ol><li><h6 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Thread1</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"运行："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Thread1 thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"jordan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread1 thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token string">"kobe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><p>jordan运行：0<br>kobe运行：0<br>kobe运行：1<br>kobe运行：2<br>jordan运行：1<br>kobe运行：3<br>jordan运行：2<br>kobe运行：4<br>jordan运行：3<br>jordan运行：4</p><blockquote><p>注意：</p><ol><li>start() 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的</li><li>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程</li><li>Thread.sleep() 方法调用目的是不让当前线程独自霸占该进程所获取的 CPU 资源，以留出一定时间给其他线程执行的机会</li><li>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的</li><li>start 方法重复调用的话，会出现 java.lang.IllegalThreadStateException 异常</li></ol></blockquote><h6 id="2-实现Runable接口"><a href="#2-实现Runable接口" class="headerlink" title="2.实现Runable接口"></a>2.实现Runable接口</h6><pre class=" language-Java"><code class="language-Java">package com.test.thread;public class Thread2 implements Runnable {    private String name;    public Thread2(String name) {        super();        this.name = name;    }    @Override    public void run() {        // TODO Auto-generated method stub        for (int i = 0; i < 5; i++) {            System.out.println(name+"运行："+i);        }        try {            Thread.sleep((long) (Math.random()*10));        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}//测试类package com.test.thread;public class Test2 {    public static void main(String[] args) {        // TODO Auto-generated method stub        new Thread(new Thread2("jordan")).start();        new Thread(new Thread2("kobe")).start();    }}</code></pre><h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><p>如果一个类继承 Thread，则不适合资源共享。但是如果实现了 Runable 接口的话，则很容易的实现资源共享</p><h6 id="总结：（实现Runable接口继承Thread的优点）"><a href="#总结：（实现Runable接口继承Thread的优点）" class="headerlink" title="总结：（实现Runable接口继承Thread的优点）"></a>总结：（实现Runable接口继承Thread的优点）</h6><ol><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免Java单继承的缺点</li><li>增加程序的健壮性，代码可以被多个线程共享，代码和数据共享</li><li>线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</li></ol><blockquote><p>注意：main 方法其实也是一个线程。在 java 中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到 CPU 的资源</p></blockquote><h5 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h5><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p><p>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>（一）、等待阻塞：运行的线程执行 wait() 方法，JVM 会把该线程放入等待池中。(wait 会释放持有的锁)</p><p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中。</p><p>（三）、其他阻塞：运行的线程执行 sleep() 或 join() 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。（注意, sleep 是不会释放持有的锁）</p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。</p><h5 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h5><ol><li><p>调整线程优先级：Java 线程有优先级，优先级高的线程会获得较多的运行机会</p><p>Java 线程的优先级用整数表示，取值范围是 1~10，Thread 类有以下三个静态常量：</p><blockquote><pre class=" language-Java"><code class="language-Java"></code></pre><p>static int MAX_PRIORITY</p><pre><code>   //线程可以具有的最高优先级，取值为10。</code></pre><p>static int MIN_PRIORITY</p><pre><code>   //线程可以具有的最低优先级，取值为1。</code></pre><p>static int NORM_PRIORITY</p><pre><code>   //分配给线程的默认优先级，取值为5。</code></pre><pre><code></code></pre></blockquote></li></ol><p>Thread 类的 setPriority() 和 getPriority() 方法分别用来设置和获取线程的优先级</p><p>每个线程都有默认的优先级。主线程的默认优先级为 Thread.NORM_PRIORITY</p><p>线程的优先级有继承关系，比如 A 线程中创建了 B 线程，那么 B 将和 A 具有相同的优先级</p><p>JVM 提供了 10 个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用 Thread 类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式</p></li><li><p>线程睡眠（sleep()）:Thread()的方法，使线程转到阻塞状态，结束后，线程转入就绪（Runable）状态</p></li><li><p>线程等待（wait()）:Object()的方法，使线程等待，直到其他线程调用此对象的notify(all)()方法时方可唤醒此线程</p></li><li><p>线程让步（yield()）:Thread()的方法，暂停正在执行的线程，将执行让给有优先级相同或者更高的线程执行</p></li><li><p>线程加入（join()）:Thread()的方法，在当前线程调用其他线程的join()方法，当前线程转入阻塞状态，直到被调用的线程运行完毕，当前线程由阻塞状态转为就绪状态</p></li><li><p>线程唤醒（notify()）:Object()的方法，</p></li></ol><p>注意：Thread 中 suspend() 和 resume() 两个方法在 JDK1.5 中已经废除，不再介绍。因为有死锁倾向</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multi-thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashcode&amp;equals</title>
      <link href="/2018/12/20/HashCodeAndEquals/"/>
      <url>/2018/12/20/HashCodeAndEquals/</url>
      
        <content type="html"><![CDATA[<h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><p>你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><pre class=" language-Java"><code class="language-Java">public native int hashCode();</code></pre><h4 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode"></a>为什么要有hashCode</h4><p><strong>我们以“Hash5Set如何检查重复”为例子来说明为什么要有hashCode：</strong></p><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p><h4 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h4><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h4 id="为什么两个对象有相同的hashcode值，它们也不一定是相等的？"><a href="#为什么两个对象有相同的hashcode值，它们也不一定是相等的？" class="headerlink" title="为什么两个对象有相同的hashcode值，它们也不一定是相等的？"></a>为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashCodeAndEquals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time</title>
      <link href="/2018/11/20/Time/"/>
      <url>/2018/11/20/Time/</url>
      
        <content type="html"><![CDATA[<h2 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h2><h4 id="时间："><a href="#时间：" class="headerlink" title="时间："></a>时间：</h4><h4 id="时区："><a href="#时区：" class="headerlink" title="时区："></a>时区：</h4><p>​    地球是圆的，每个地区看到的太阳升起的时间是不相同的，也就是说，东8区的北京人民的手表显示的8:00和东1区欧洲人民手表显示的1:00是相同的时刻</p><pre class=" language-Java"><code class="language-Java">"2018-10-14 08:00 +8:00" = "2018-10-14 01:00 +1:00"    </code></pre><p>​    而到了Java语言里面，也就是数据库（MySQL），Java用的是 new Date() 方法来保存当时日期，但是到数据库的 DateTime 类型是没有时区信息的，如果此时用 DateTime 格式保存日期，就会丢失时区信息，如果服务器更该地址，从数据库读出来的日期数据就是错误的！</p><p>​    用 timeStamp 类型保存总不会丢失时区信息了吧？确实没丢失。但是，timeStamp 保存的时间最长不能超过 2038-01-19 年，而且要考虑每个数据的 timeStamp 类型都有可能不一样。不过它的优质就是做一下国际项目的时候自动转换时区问题。</p><p>​    用datetime，占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。储存的时间不带有时区。</p><pre><code> JDK8 中新的时间 API LocalDateTime 中，有着丰富的时区转换的方法，但是也是要经过复杂是转换计算。</code></pre><h4 id="解决以上问题需要引入”绝对时间”-这个概念。"><a href="#解决以上问题需要引入”绝对时间”-这个概念。" class="headerlink" title="解决以上问题需要引入”绝对时间” 这个概念。"></a>解决以上问题需要引入”绝对时间” 这个概念。</h4><p>​    绝对时间不需要年月日，而是以秒来计时。当前时间是指从一个基准时间（1970-1-1 00:00:00 +0:00），到现在的秒数，用一个整数表示。</p><p>​    而且很重要的一点就是，在现有的编程语言中，都提供了方法来获取时间戳，这对于不同语言的项目交互来说，不要太方便！</p><p>​    数据库用数值保存时间戳的诸多好处：</p><ol><li>在数据库中日期比较不要太方便，小学一年级就会的数学题，而且性能好；</li><li>数值对于任何系统交互来说都不存在障碍；</li><li>基于绝对时间的数值存储，不存在时区问题；</li><li>在交互过程中，摒弃没必要的重重转换，一个数字走天下，用户需要显示，前端只需要拿到时间戳显示正确的本地时间；</li><li>解决了由于各个数据库对于时间实现的不一样导致的问题，比如说 Mysql 的时间函数跟 Oracle 会有一些差别，假如你现在的 sql 有时间函数，换了数据库很可能就会出错。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DateTime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2018/09/20/SpringMVC/"/>
      <url>/2018/09/20/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h4 id="文字描述："><a href="#文字描述：" class="headerlink" title="文字描述："></a>文字描述：</h4><p>1、  用户发送请求至前端控制器DispatcherServlet。</p><p>2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p><p>3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p><p>4、  DispatcherServlet调用HandlerAdapter处理器适配器。</p><p>5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p><p>6、  Controller执行完成返回ModelAndView。</p><p>7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p><p>9、  ViewReslover解析后返回具体View。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、 DispatcherServlet响应用户。</p><p>组件描述：</p><p><strong>1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong><br>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p><p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong><br>作用：根据请求的url查找Handler<br>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><strong>3、处理器适配器HandlerAdapter</strong><br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p><strong>4、处理器Handler(需要工程师开发)</strong><br><strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong><br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p><p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong><br>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p><strong>6、视图View(需要工程师开发jsp…)</strong><br>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Night watcher swear</title>
      <link href="/2018/09/07/Aray/"/>
      <url>/2018/09/07/Aray/</url>
      
        <content type="html"><![CDATA[<h3 id="Night-watcher-swear"><a href="#Night-watcher-swear" class="headerlink" title="Night watcher swear"></a>Night watcher swear</h3><p>Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the fire that burns against the cold, the light that brings the dawn, the horn that wakes the sleepers, the shield that guards the realms of men. I pledge my life and honor to the Night’s Watch, for this night and all the nights to come.</p><p>长夜将至，我从今开始守望，至死方休。我将不娶妻、不封地、不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死於斯。我是黑暗中的利剑，长城上的守卫。我是抵御寒冷的烈焰，破晓时分的光线，唤醒眠者的号角，守护王国的坚盾。我将生命与荣耀献给守夜人，今夜如此，夜夜皆然。</p>]]></content>
      
      
      <categories>
          
          <category> xxx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitToGithub</title>
      <link href="/2018/09/07/GitToGithub/"/>
      <url>/2018/09/07/GitToGithub/</url>
      
        <content type="html"><![CDATA[<h3 id="GitToGithub"><a href="#GitToGithub" class="headerlink" title="GitToGithub"></a>GitToGithub</h3><h4 id="0、新建文件夹"><a href="#0、新建文件夹" class="headerlink" title="0、新建文件夹"></a>0、新建文件夹</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036553006.png" alt="1559036553006"></p><h4 id="1、在此文件夹右键Git-Bash-Here，输入命令"><a href="#1、在此文件夹右键Git-Bash-Here，输入命令" class="headerlink" title="1、在此文件夹右键Git Bash Here，输入命令"></a>1、在此文件夹右键Git Bash Here，输入命令</h4><pre class=" language-Java"><code class="language-Java">git init</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036600072.png" alt="1559036600072"></p><p>此步操作为初始化git工作区间</p><h4 id="2、将需要上传的项目复制到工作区间"><a href="#2、将需要上传的项目复制到工作区间" class="headerlink" title="2、将需要上传的项目复制到工作区间"></a>2、将需要上传的项目复制到工作区间</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036752091.png" alt="1559036752091"></p><h4 id="3、输入命令git-status-查看git工作区间的文件变化"><a href="#3、输入命令git-status-查看git工作区间的文件变化" class="headerlink" title="3、输入命令git status 查看git工作区间的文件变化"></a>3、输入命令git status 查看git工作区间的文件变化</h4><pre><code>git status</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036885875.png" alt="1559036885875"></p><h4 id="4、输入命令git-add-将文件加入到暂存区"><a href="#4、输入命令git-add-将文件加入到暂存区" class="headerlink" title="4、输入命令git add . 将文件加入到暂存区"></a>4、输入命令git add . 将文件加入到暂存区</h4><pre><code>git add .</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559036995464.png" alt="1559036995464"></p><h4 id="5、将文件提交到本地仓库"><a href="#5、将文件提交到本地仓库" class="headerlink" title="5、将文件提交到本地仓库"></a>5、将文件提交到本地仓库</h4><pre><code>git commit -m &quot;the first commit&quot;</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037091035.png" alt="1559037091035"></p><h4 id="6、在Github种新建仓库"><a href="#6、在Github种新建仓库" class="headerlink" title="6、在Github种新建仓库"></a>6、在Github种新建仓库</h4><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037194341.png" alt="1559037194341"></p><p>7、复制仓库链接（https链接）</p><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037237509.png" alt="1559037237509"></p><h4 id="8、将本地仓库关联到Github仓库"><a href="#8、将本地仓库关联到Github仓库" class="headerlink" title="8、将本地仓库关联到Github仓库"></a>8、将本地仓库关联到Github仓库</h4><pre><code>git remote add origin https://...</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037332932.png" alt="1559037332932"></p><h4 id="9、将本地仓库同步到GitHub仓库"><a href="#9、将本地仓库同步到GitHub仓库" class="headerlink" title="9、将本地仓库同步到GitHub仓库"></a>9、将本地仓库同步到GitHub仓库</h4><pre><code>git push origin master</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1559037744888.png" alt="1559037744888"></p><h3 id="一点一点积累"><a href="#一点一点积累" class="headerlink" title="一点一点积累"></a>一点一点积累</h3><p>git拉取远程仓库代码与本地合并：</p><pre><code>git pull origin master</code></pre><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1562244421283.png" alt="1562244421283"></p>]]></content>
      
      
      <categories>
          
          <category> Git&amp;Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2018/08/02/MyBatis/"/>
      <url>/2018/08/02/MyBatis/</url>
      
        <content type="html"><![CDATA[<h4 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h4><h5 id="配置文件与映射文件"><a href="#配置文件与映射文件" class="headerlink" title="配置文件与映射文件"></a>配置文件与映射文件</h5><h5 id="MyBatisCRUD操作"><a href="#MyBatisCRUD操作" class="headerlink" title="MyBatisCRUD操作"></a>MyBatisCRUD操作</h5><h5 id="ResultType与ResultMap区别"><a href="#ResultType与ResultMap区别" class="headerlink" title="ResultType与ResultMap区别"></a>ResultType与ResultMap区别</h5><p>实体类与表中字段不一致时</p><ol><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致，这样就可以表的字段名和实体类的属性名一一对应上了，这种方式是通过在sql语句中定义别名来解决字段名和属性名的映射关系的。</li><li>通过<resultmap>来映射字段名和实体类属性名的一一对应关系。这种方式是使用MyBatis提供的解决方式来解决字段名和属性名的映射关系的</resultmap></li></ol><h5 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h5><p>​    if，choose (when, otherwise)，trim (where, set)，foreach</p><h5 id="一对一，一对多，多对多高级映射（association-collection）"><a href="#一对一，一对多，多对多高级映射（association-collection）" class="headerlink" title="一对一，一对多，多对多高级映射（association,collection）"></a>一对一，一对多，多对多高级映射（association,collection）</h5><ol><li>一对一关联，使用assacation标签</li><li>一对多关联，使用collection标签。collection标签来解决一对多的关联查询，ofType属性指定集合中元素的对象类型         </li></ol><h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p>​    mybatis默认没有开启延迟加载，需要在MyBaits-Config.xml中setting配置</p><p>​    使用association、collection能实现表间关联，association、collection也具备延迟加载功能延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><h5 id="一级缓存、二级缓存"><a href="#一级缓存、二级缓存" class="headerlink" title="一级缓存、二级缓存"></a>一级缓存、二级缓存</h5><ol><li>一级缓存默认开启，作用域一个sqlSession中，两个查询之后第二次查询会在缓存之中查找，提交查找效率，如果进行commit()（insert,update,delete）操作，则清空缓存。</li><li>二级缓存默认开启，需要在xml文件中配置，其作用域为一个Mapper，即namespace，所以需要在对应的xml文件中进行配置。而且缓存可自定义存储源（Redis,EhCache,MemcCache）</li></ol><h5 id="分页、批量"><a href="#分页、批量" class="headerlink" title="分页、批量"></a>分页、批量</h5><ol><li>mybatis的分页功能，可以自己利用mysql代码实现，也可以利用mybatis分页插件,如pageHelper</li><li>批量则依赖于SQL语句</li></ol><h5 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h5>]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2018/06/12/ConcurrentHashMap/"/>
      <url>/2018/06/12/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap这个类在java.lang.current包中，这个包中的类都是线程安全的。</p><p>ConcurrentHashMap底层存储数据的结构与1.8的HashMap是一样的，都是数组+链表（或红黑树）的结构。</p><p>在日常的开发中，我们最长用到的键值对存储结构的是HashMap，但是我们知道，这个类是非线程安全的，<strong>在高并发的场景下，在进行put操作的时候有可能进入死循环从而使服务器的cpu使用率达到100%</strong>；</p><p>sun公司因此也给出了与之对应的线程安全的类。在jdk1.5以前，使用的是HashTable，这个类为了保证线程安全，在每个类中都添加了synchronized关键字，而想而知在高并发的情景下相率是非常低下的。</p><p>为了解决HashTable效率低下的问题，官网在jdk1.5后推出了ConcurrentHashMap来替代饱受诟病的HashTable。</p><p>jdk1.5后ConcurrentHashMap使用了分段锁的技术。在整个数组中被分为多个segment，每次get，put，remove操作时就锁住目标元素所在的segment中，因此segment与segment之前是可以并发操作的，上述就是jdk1.5后实现线程安全的大致思想。</p><p>但是，从描述中可以看出一个问题，就是如果出现比较机端的情况，所有的数据都集中在一个segment中的话，在并发的情况下相当于锁住了全表，这种情况下其实是和HashTable的效率出不多的，但总体来说相较于HashTable，效率还是有了很大的提升。</p><p>jdk1.8后，ConcurrentHashMap摒弃了segment的思想，转而使用cas+synchronized组合的方式来实现并发下的线程安全的，这种实现方式比1.5的效率又有了比较大的提升。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaCollection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==AndEq</title>
      <link href="/2018/06/12/==AndEqulas/"/>
      <url>/2018/06/12/==AndEqulas/</url>
      
        <content type="html"><![CDATA[<h2 id="AndEq"><a href="#AndEq" class="headerlink" title="==AndEq"></a>==AndEq</h2><p>==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来判断两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li></ul><pre class=" language-Java"><code class="language-Java">public class test04 {    public static void main(String[] args) {        String a = new String("ab"); // a 为一个引用        String b = new String("ab"); // b为另一个引用,对象的内容一样        String aa = "ab"; // 放在常量池中        String bb = "ab"; // 从常量池中查找        if (aa == bb) // true            System.out.println("aa==bb");        if (a == b) // false，非同一对象            System.out.println("a==b");        if (a.equals(b)) // true            System.out.println("aEQb");        if (42 == 42.0) { // true            System.out.println("true");        }    }}</code></pre><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Param</title>
      <link href="/2018/03/04/Param/"/>
      <url>/2018/03/04/Param/</url>
      
        <content type="html"><![CDATA[<h2 id="Param注解的学习与总结"><a href="#Param注解的学习与总结" class="headerlink" title="@Param注解的学习与总结"></a>@Param注解的学习与总结</h2><p>参考博客：</p><h3 id="场景一：方法有多个参数，需要-Param-注解"><a href="#场景一：方法有多个参数，需要-Param-注解" class="headerlink" title="场景一：方法有多个参数，需要 @Param 注解"></a>场景一：方法有多个参数，需要 @Param 注解</h3><p>最常见的需要添加@Param注解的场景</p><pre class=" language-Java"><code class="language-Java">@Mapperpublic interface UserMapper {    Integer insert(@Param("username") String username, @Param("address") String address);}</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insert<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.javaboy.helloboot.bean.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    insert into user (username,address) values (#{username},#{address});<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><h3 id="场景二：方法参数要取别名，需要-Param-注解"><a href="#场景二：方法参数要取别名，需要-Param-注解" class="headerlink" title="场景二：方法参数要取别名，需要 @Param 注解"></a>场景二：方法参数要取别名，需要 @Param 注解</h3><pre class=" language-Java"><code class="language-Java">@Mapperpublic interface UserMapper {    User getUserByUsername(@Param("name") String username);}</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserByUsername<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.javaboy.helloboot.bean.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user where username=#{name};<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h3 id="场景三：XML-中的-SQL-使用了-，那么参数中也需要-Param-注解"><a href="#场景三：XML-中的-SQL-使用了-，那么参数中也需要-Param-注解" class="headerlink" title="场景三：XML 中的 SQL 使用了 $ ，那么参数中也需要 @Param 注解"></a>场景三：XML 中的 SQL 使用了 $ ，那么参数中也需要 @Param 注解</h3><p>会有sql注入的问题</p><pre class=" language-Java"><code class="language-Java">@Mapperpublic interface UserMapper {    List<User> getAllUsers(@Param("order_by")String order_by);}</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAllUsers<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.javaboy.helloboot.bean.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_by!<span class="token punctuation">=</span>null and order_by!<span class="token punctuation">=</span><span class="token punctuation">'</span><span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        order by ${order_by} desc    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h3 id="场景四：动态-SQL-，如果在动态-SQL-中使用了参数作为变量，那么也需要-Param-注解，即使你只有一个参数"><a href="#场景四：动态-SQL-，如果在动态-SQL-中使用了参数作为变量，那么也需要-Param-注解，即使你只有一个参数" class="headerlink" title="场景四：动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数"></a>场景四：动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数</h3><p>如果在动态 SQL 中用到了 参数作为判断条件，那么也是一定要加 @Param 注解的</p><pre class=" language-Java"><code class="language-Java">@Mapperpublic interface UserMapper {    List<User> getUserById(@Param("id")Integer id);}</code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserById<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.javaboy.helloboot.bean.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id!<span class="token punctuation">=</span>null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        where id=#{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2018/02/24/MySQL/"/>
      <url>/2018/02/24/MySQL/</url>
      
        <content type="html"><![CDATA[<h4 id="MySQL感想"><a href="#MySQL感想" class="headerlink" title="MySQL感想"></a>MySQL感想</h4><h4 id="行是物理存在的，而分组是逻辑存在的。"><a href="#行是物理存在的，而分组是逻辑存在的。" class="headerlink" title="行是物理存在的，而分组是逻辑存在的。"></a>行是物理存在的，而分组是逻辑存在的。</h4><p>一行数据和一列数据都能被人们感知，一行数据会携带一个主键；而一列数据，不仅有列名，还有列的类型。</p><p>看的见的东西很重要，但是看不见的东西也同样重要，甚至看错的东西更重要。这个人生哲理放在数据库里面，同样成立</p><p>在一次测试种，10000 条记录的数据表中，查找一次平均需要 5000 次比较，而在使用了索引的表中只需要 14 次。</p><p>10000 对 14 的对比</p><h4 id="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"><a href="#索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。" class="headerlink" title="索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。"></a>索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。</h4><ol><li>索引占用一定的磁盘空间，就像新华字典有目录便要比没有目录的厚一点</li><li>索引大大减缓了插入和删数据的效率，因为每次插入都需要更新索引，一个表拥有的索引越多，进行写操作时平均性能就急剧下降</li></ol><p>数据分组用来将数据分为多个逻辑组，从而可以对每个组进行聚合运算，使用方式为：GROUP BY分组字段。分组语句必须和聚合函数一起使用，GROUP BY子句负责将数据分成逻辑组，而聚函数则对每一个组进行统计计算。</p><p>虽然GROUP BY子句常常和聚合函数起使用，不过GROUP BY子句并不是不能离开聚合函数而单独使用的</p><h4 id="数据分组有以下三大特点"><a href="#数据分组有以下三大特点" class="headerlink" title="数据分组有以下三大特点"></a>数据分组有以下三大特点</h4><ol><li><h5 id="分组与聚合函数"><a href="#分组与聚合函数" class="headerlink" title="分组与聚合函数"></a>分组与聚合函数</h5><p>要分组的所有列都必须位于 GROUP BY子句的列名列表中，也就是没有出现在GROUP BY子句中的列(聚合函数除外)是不能放到SELECET语句后的列名列表中的。比如下面的SQL语句是错误的：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age, salary FROM t_employee GROUP BY age;</code></pre><p>道理非常简单，采用分组以后的查询结果集是以分组形式提供的，由于每组中人员的工资都不样，所以就不存在能够统代表本组工资水平的salary字段了，所以上面的SQL语句是错误的。不过每组中员工的平均工资却能够统一代表本组工水平，所以可以对Salary使用聚合函数，下面的SQL语句则是正确的：</p><pre><code>SELECT age, AVG(salary) FROM t_Employee GROUP BY age;</code></pre></li><li><h5 id="多级数据分组"><a href="#多级数据分组" class="headerlink" title="多级数据分组"></a>多级数据分组</h5><p>GROUP BY子句中可以指定多个列，只需要将多个列的列名用逗号隔开即。指定多个分组规则以后，数据库系统将按照定义的分组顺序来对数据进行逐分组。首先按照第一个分组列进行分组，然后在每个小组内按照第一个分组列行再次分组…逐层分组，从而实现“组中组”的效果，而查询的结果集是以末一级分组来进行输出的。比如下面的SQL语句将会列出所有分公司的所有门的情况：</p><pre class=" language-mysql"><code class="language-mysql">SELECT subcompany, department FROM t_employee GROUP BY subcompany, department;</code></pre></li><li><h5 id="数据分组特点三：数据分组过滤使用HAVING语句"><a href="#数据分组特点三：数据分组过滤使用HAVING语句" class="headerlink" title="数据分组特点三：数据分组过滤使用HAVING语句"></a>数据分组特点三：数据分组过滤使用HAVING语句</h5><p>有的时候需要对部分分组进行过滤，比如只检索人数大于1的年龄段，有的开发人员会使用下面的SQL语句：</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age where count(*) > 1 ;</code></pre><p>在数据库系统中执行上面的SQL语句时，数据库系统会提示语法错误。这是因为聚合函数不能在WHERE语句中使用，必须使用HAVING子句来代替，比如:</p><pre class=" language-mysql"><code class="language-mysql">SELECT age,count(*) FROM t_employee GROUP BY age having count(*) > 1 ;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMapAndConcurrentHashMap</title>
      <link href="/2018/02/21/HashMapAndConcurrentHashMap/"/>
      <url>/2018/02/21/HashMapAndConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h1><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap:"></a>HashMap:</h3><h5 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h5><p><img src="C:\Users\Goffy\Desktop\继承图谱\HashMap.jpg" alt></p><h5 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h5><p>JDK1.8之前：数组+链表（散列集）</p><p>JDK1.8之后：数组+链表（散列集）+红黑二叉树</p><h5 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891042167.png" alt="1557891042167"></p><ol><li>序列化机制验证版本</li><li>初始容量</li><li>最大容量，2的31次方</li><li>默认装载因子</li><li>当添加一个元素被添加到有至少TREEIFY_THRESHOLD节点的桶中，桶中链表将转化为链表</li><li>同上，不过是将树形结构转化为链表</li><li>桶可能被转化成树形结构的最小容量</li></ol><h6 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h6><pre class=" language-Java"><code class="language-Java">private static final long serialVersionUID = 362498820763181265L;static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16static final int MAXIMUM_CAPACITY = 1 << 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557891742915.png" alt="1557891742915"></p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="C:\Users\Goffy\AppData\Roaming\Typora\typora-user-images\1557892222219.png" alt="1557892222219"></p><h5 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h5><ul><li>无序、允许为Null、非同步</li><li>底层由散列表实现</li><li>初始容量和加载因子对其影响较大</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaCollection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO/NIO</title>
      <link href="/2018/02/20/JavaIO/"/>
      <url>/2018/02/20/JavaIO/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaIO-NIO"><a href="#JavaIO-NIO" class="headerlink" title="JavaIO/NIO"></a>JavaIO/NIO</h3><h3 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h3><p>在Java.io包下主要包括两种流输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。其中字节流以字节单位来处理输入、输出操作。而字符流则以字符处理输入、输出操作。</p><ul><li><p>字符流</p><ul><li>Reader<ul><li>BufferedReader</li><li>InputStreamReader</li><li>StringReader</li><li>CharArrayReader</li><li>FileReader</li><li>…</li></ul></li><li>Writer<ul><li>BufferedWriter</li><li>OutputStreamWriter</li><li>StringWriter</li><li>CharArrayWriter</li><li>FileWriter</li><li>…</li></ul></li></ul></li><li><p>字节流</p><ul><li>InputStream<ul><li>FileInputStream</li><li>StringBufferInputStream</li><li>ByteArrayInputStream</li><li>…</li></ul></li><li>OutputStream<ul><li>FileOutputStream</li><li>StringBufferOutputStream</li><li>ByteArrayOutputStream</li><li>…</li></ul></li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Non-blocking I/O</p><p>一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式</p><p>核心对象：</p><ul><li>Channel （通道）</li><li>Buffer （缓冲）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList.asList()</title>
      <link href="/2018/02/20/Arrays.asList/"/>
      <url>/2018/02/20/Arrays.asList/</url>
      
        <content type="html"><![CDATA[<h3 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h3><h3 id="Arrays-asList-可以将一个数组转化为集合，但是："><a href="#Arrays-asList-可以将一个数组转化为集合，但是：" class="headerlink" title="Arrays.asList()可以将一个数组转化为集合，但是："></a>Arrays.asList()可以将一个数组转化为集合，但是：</h3><p>该方法为泛型方法，具体实现为</p><pre class=" language-Java"><code class="language-Java">public static <T> List<T> asList(T... a) {    return new ArrayList<>(a);}</code></pre><p>使用时必须注意的事项：</p><ol><li><p>传递的必须为对象数组，而不是基本类型。</p><pre class=" language-Java"><code class="language-Java">int [] myArray1 = { 1, 2, 3 };List myList1 = Arrays.asList(myArray1);System.out.println(myList1.size());//1System.out.println(myList1.get(0));//数组地址值 [I@1b6d3586</code></pre></li><li><p>当传入一个基本数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>解决这个问题只需要将数组类型变成他的包装类型</p><pre class=" language-Java"><code class="language-Java">Integer[] myArray1 = { 1, 2, 3 };</code></pre></li><li><p>使用集合的修改方法:add()、remove()、clear()会抛出异常。</p><pre class=" language-Java"><code class="language-Java">List myList1 = Arrays.asList(1, 2, 3);myList1.add(4);//运行时报错：UnsupportedOperationExceptionmyList1.remove(1);//运行时报错：UnsupportedOperationExceptionmyList1.clear();//运行时报错：UnsupportedOperationException</code></pre><p>因为：Arrays.asList()的返回值是 <code>java.util.Arrays</code> 的一个内部类，并不是java.util.ArrayList</p><pre class=" language-Java"><code class="language-Java">System.out.println("-----------"+myList1.getClass());//-----------class java.util.Arrays$ArrayList</code></pre></li></ol><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些</p><pre class=" language-Java"><code class="language-Java"> private static class ArrayList<E> extends AbstractList<E>        implements RandomAccess, java.io.Serializable    {        ...        @Override        public E get(int index) {          ...        }        @Override        public E set(int index, E element) {          ...        }        @Override        public int indexOf(Object o) {          ...        }        @Override        public boolean contains(Object o) {           ...        }        @Override        public void forEach(Consumer<? super E> action) {          ...        }        @Override        public void replaceAll(UnaryOperator<E> operator) {          ...        }        @Override        public void sort(Comparator<? super E> c) {          ...        }    }</code></pre><p><code>java.util.AbstractList</code>的<code>remove()</code>,理解为什么会抛出UnsupportedOperationException()异常</p><pre class=" language-Java"><code class="language-Java">public E remove(int index) {    throw new UnsupportedOperationException();}</code></pre><h3 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList?"></a>如何正确的将数组转换为ArrayList?</h3><ol><li><p><strong>最简便的方法(推荐)</strong></p><pre class=" language-Java"><code class="language-Java">List list = new ArrayList<>(Arrays.asList("a", "b", "c"))</code></pre></li><li><p><strong>使用 Java8 的Stream(推荐)</strong></p><pre class=" language-Java"><code class="language-Java">Integer [] myArray = { 1, 2, 3 };List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = { 1, 2, 3 };List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre></li><li><p><strong>使用 Guava(推荐)</strong></p><ol><li><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="noopener"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="noopener"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="noopener"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><pre class=" language-Java"><code class="language-Java">List<String> il = ImmutableList.of("string", "elements");  // from varargsList<String> il = ImmutableList.copyOf(aStringArray);      // from array</code></pre></li><li><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="noopener"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="noopener"><code>newArrayList()</code></a>工厂方法：</p><pre class=" language-Java"><code class="language-Java">List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collectionList<String> l2 = Lists.newArrayList(aStringArray);               // from arrayList<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs</code></pre></li></ol></li><li><p><strong>使用 Apache Commons Collections</strong></p><pre class=" language-Java"><code class="language-Java">List<String> list = new ArrayList<String>();CollectionUtils.addAll(list, str);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arrays </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet</title>
      <link href="/2018/02/20/servlet/"/>
      <url>/2018/02/20/servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><h3 id="处理中文乱码问题"><a href="#处理中文乱码问题" class="headerlink" title="处理中文乱码问题"></a>处理中文乱码问题</h3><h5 id="请求中文乱码解决"><a href="#请求中文乱码解决" class="headerlink" title="请求中文乱码解决"></a>请求中文乱码解决</h5><ol><li>使用String进行数据重新编码</li></ol><pre class=" language-Java"><code class="language-Java">uname = new String(uname.getBytes("iso8859-1"),"utf-8");</code></pre><ol start="2"><li><p>使用公共配置</p><ul><li><p>get方法：</p><p>步骤一：</p><pre class=" language-Java"><code class="language-Java">request.setCharacterEncoding("utf-8");</code></pre><p>步骤二：</p><p>在Tomcat的目录下的conf目录中的修改server.xml文件，在Connector标签中增加useBodyEncodingForURI=”true”</p></li><li><p>post方法：</p><pre class=" language-Java"><code class="language-Java">resp.setContentType("text/html; charset=UTF-8");</code></pre></li></ul></li></ol><h3 id="forward-与-sendRedirect"><a href="#forward-与-sendRedirect" class="headerlink" title="forward 与 sendRedirect"></a>forward 与 sendRedirect</h3><table><thead><tr><th></th><th>重定向</th><th>请求转发</th></tr></thead><tbody><tr><td>第二次请求是谁请求的？</td><td>浏览器</td><td>服务器</td></tr><tr><td>浏览器发生了几次请求？</td><td>2</td><td>1</td></tr><tr><td>servlet可以共享request吗？</td><td>不可以</td><td>可以</td></tr><tr><td>地址栏是否发生改变？</td><td>是</td><td>否</td></tr><tr><td>浏览器显示的是那一次的访问地址？</td><td>最后一次</td><td>第一次</td></tr><tr><td>可以跳转到什么资源</td><td>任意资源</td><td>项目内部</td></tr><tr><td>第二次请求路径是？</td><td>绝对路径</td><td>内部路径</td></tr></tbody></table><ol><li><p>​    重定向（sendRedirect）</p><pre class=" language-Java"><code class="language-Java">resp.sendRedirect("path");</code></pre><ol><li>​    两次请求    两个request对象，数据不共享</li><li>​    浏览器地址栏信息改变</li></ol></li><li><p>请求转发（forward） </p><pre class=" language-Java"><code class="language-Java">req.getRequestDispatcher("path").forward(req, resp);</code></pre><ol><li>一次请求</li><li>浏览器地址不发生改变</li></ol></li><li><p>使用场景：</p><ol><li>如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向</li><li>如果请求被servlet接收后，无法进行处理，建议使用重定向定位到可以处理资源的servlet上</li></ol></li><li><p>选择</p><ol><li>重定向的速度比转发慢，因为浏览器还得发出一个新的请求，如果在使用转发和重定向都无所谓的时候建议使用转发。</li><li>因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ValueAndRefe</title>
      <link href="/2017/12/20/ValueAndReference/"/>
      <url>/2017/12/20/ValueAndReference/</url>
      
        <content type="html"><![CDATA[<h4 id="参数传递给方法（或函数）"><a href="#参数传递给方法（或函数）" class="headerlink" title="参数传递给方法（或函数）"></a>参数传递给方法（或函数）</h4><blockquote><p><strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong></p></blockquote><blockquote><p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容</strong></p></blockquote><h4 id="eg1"><a href="#eg1" class="headerlink" title="eg1:"></a>eg1:</h4><pre class=" language-Java"><code class="language-Java">    /**     * 一个方法不能修改一个基本类型的参数的值     */    public static void main(String[] args) {        int num1 = 10;        int num2 = 20;        swap(num1,num2);        System.out.println("num1="+num1);        System.out.println("num2="+num2);    }    public static void swap(int a,int b){        int temp = a;        a=b;        b=temp;        System.out.println("a="+a);//a只是Num1的拷贝，num1本身并不会改变        System.out.println("b="+b);    }    output:    a=20    b=10    num1=10    num2=20</code></pre><p>一个方法不能修改一个基本数据类型的参数，而对象引用作为参数非也</p><h4 id="eg2"><a href="#eg2" class="headerlink" title="eg2:"></a>eg2:</h4><pre><code>    /**     * 方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象     * @param args     */    public static void main(String[] args) {        int [] arr = {1,2,3,4,5};        System.out.println(arr[0]);        exchange(arr);        System.out.println(arr[0]);    }    public static void exchange(int [] array){        array[0]=0;    }    output:    1    0</code></pre><p>可以明显的看出：</p><p><strong>方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象</strong></p><h4 id="eg3"><a href="#eg3" class="headerlink" title="eg3:"></a>eg3:</h4><pre class=" language-Java"><code class="language-Java">    public static void main(String[] args) {        Players players1 = new Players("Jordan");        Players players2 = new Players("Kobe");        Test03.swap(players1,players2);        System.out.println("players1="+players1.getName());        System.out.println("players2="+players2.getName());    }    public static void swap(Players x,Players y){        Players temp = x;        x=y;        y=temp;        System.out.println("players1="+x.getName());        System.out.println("players2="+y.getName());    }    output:x=Kobey=Jordanplayers1=Jordanplayers2=Kobe</code></pre><p>和第二个例子一样，<strong>方法并没有改变存储在变量 players1和 players1 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p>参考：</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FilterAndInterceptor</title>
      <link href="/2017/11/03/Filter&amp;Interceptor/"/>
      <url>/2017/11/03/Filter&amp;Interceptor/</url>
      
        <content type="html"><![CDATA[<h3 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h3><h3 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h3><p>​    依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤。但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据。</p><p><strong>比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等</strong></p><h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><p>​    依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理</p><h3 id="过滤器和拦截器的区别："><a href="#过滤器和拦截器的区别：" class="headerlink" title="过滤器和拦截器的区别："></a>过滤器和拦截器的区别：</h3><p>​        ①拦截器是基于java的反射机制的，而过滤器是基于函数回调。</p><p>​        ②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</p><p>​        ③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</p><p>​        ④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</p><p>​        ⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</p><p>​        ⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p><h4 id="过滤器主要代码实现："><a href="#过滤器主要代码实现：" class="headerlink" title="过滤器主要代码实现："></a>过滤器主要代码实现：</h4><pre class=" language-Java"><code class="language-Java">    @Override    public void init(FilterConfig filterConfig) throws ServletException {        }    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    }    @Override    public void destroy() {    }</code></pre><h4 id="拦截器主要实现代码："><a href="#拦截器主要实现代码：" class="headerlink" title="拦截器主要实现代码："></a>拦截器主要实现代码：</h4><pre class=" language-Java"><code class="language-Java">  @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //System.out.println("拦截器执行了----前1");        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        //System.out.println("拦截器执行了----后1");        //request.getRequestDispatcher("/error.jsp").forward(request,response);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        //System.out.println("拦截器执行了----最后1");    }</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。（理解：就是一堆字母中取一个B）</p></li><li><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。（理解：就是一堆字母中，干预他，通过验证的少点，顺便干点别的东西）</p></li></ol><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>javax.servlet.ServletContextListener接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁</p><p>主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等</p><p>在javax.servlet.ServletContextListener接口中定义了2种方法：</p><ul><li>void contextInitialized(ServletContextEvent sce) 监听器的初始化</li><li>void contextDestroyed(ServletContextEvent sce) 监听器销毁</li></ul><pre class=" language-Java"><code class="language-Java">package com.cn.util;  import javax.servlet.ServletContextEvent;  import javax.servlet.ServletContextListener;  public class ServletContextListener implements ServletContextListener{   //监听器的初始化  @Override  public void contextInitialized(ServletContextEvent sce) {          System.out.println("监听器ServletContextListener初始化");      }   //监听器的销毁  @Override  public void contextDestroyed(ServletContextEvent sce) {          System.out.println("监听器ServletContextListener销毁");      }  } </code></pre><p>注：项目启动时，先启动监听器，再启动过滤器。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。</li><li>拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。</li><li>监听器（Listener）：当一个事件发生的时候，你希望获得这个事件发生的详细信息，而并不想干预这个事件本身的进程，这就要用到监听器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FilterAndInterceptor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
